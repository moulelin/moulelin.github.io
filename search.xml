<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Context-Aware Attentional Graph U-Net for Hyperspectral Image Classification</title>
    <url>/2021/03/31/CAGU/</url>
    <content><![CDATA[<p><img src="/images/2_author.jpg"> </p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract :"></a>Abstract :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">Hyperspectral Image (HSI) registers hundreds of spectral bands, whose intraclass variability and interclass similarity are resourceful information to be mined. Intraclass variability reflects the non-uniform and redundancy of the spatial and semantic features extracted from HSI. Interclass similarity represents the inherent relationship between adjacent features and snapshots. Existing models extract the superficial correlation representation for HSI to tackle the classification task but fail to embed the interclass and intraclass correlations due to these models intrinsic bottlenecks. Confronting the challenges of capturing interrelation for complex data in practice, we propose a Context-Aware Attentional Graph U-Net (CAGU) to improve these two modes of representation, which is more flexible in feature enhancement. In this method, attentional Graph U-Net is capable of extracting the intraclass embeddings within a non-Euclidean space by combining similar distributing feature vertices. The Gated Recurrent Unit (GRU) is another critical component of our model to capture the context-aware dynamic interclass embeddings. Extensive experiments demonstrate that our model can efficiently outperform state-of-the-art methods across-the-board on five wide-adopted public datasets, namely Pavia University, Indian Pines, Salinas Scene-show, Houston 2013 and Houston 2018, on a par with the same scale of model parameters.
</blockquote>
<h1 id="CAGU-Architecture"><a href="#CAGU-Architecture" class="headerlink" title="CAGU Architecture :"></a>CAGU Architecture :</h1><p> <img src="/images/2_2.jpg"> </p>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results :"></a>Results :</h1><p> <img src="/images/2_3.jpg"> </p>
<h1 id="Classification-maps"><a href="#Classification-maps" class="headerlink" title="Classification maps :"></a>Classification maps :</h1><p> <img src="/images/2_5.jpg"> </p>
<h1 id="Innovation"><a href="#Innovation" class="headerlink" title="Innovation :"></a>Innovation :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph;color:black"> CAGU considers the intrinsic relationship in feature space, and promotes high cohesion of features through the graph network. CAGU can explore deeper spectral information in the image than the state-of-the-art methods, which enhances the cohesion of features and provides clear data for subsequent modules. Therefore, CAGU outperforms all the compared methods, and it can be universally employed in most models for feature enhancement, not restricted in U-Net. What’s more, GCN and GRU will not increase the parameters of the model due to the reduction in depth of U-Net.
</blockquote>
<hr>
<h1 id="Publish"><a href="#Publish" class="headerlink" title="Publish :"></a>Publish :</h1><h3 id="Journal-IEEE-Geoscience-and-Remote-Sensing-Letters"><a href="#Journal-IEEE-Geoscience-and-Remote-Sensing-Letters" class="headerlink" title="Journal : IEEE Geoscience and Remote Sensing Letters"></a>Journal : IEEE Geoscience and Remote Sensing Letters</h3><h3 id="Impact-factor-3-833"><a href="#Impact-factor-3-833" class="headerlink" title="Impact factor : 3.833"></a>Impact factor : 3.833</h3><h3 id="State-Accepted-28-Mar-2021"><a href="#State-Accepted-28-Mar-2021" class="headerlink" title="State : Accepted (28-Mar-2021)"></a>State : Accepted (28-Mar-2021)</h3><p><img src="/images/2_4.jpg"> </p>
<h1 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration :"></a>Declaration :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph;color:black;font-size:20px"> When the paper is published, we will open source the code.<br>
<p style="text-align:right;color:black;font-size:20px"> --&nbsp;Moule Lin </blockquote>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>CAGU</tag>
      </tags>
  </entry>
  <entry>
    <title>Short-term prediction of stock market price based on GA optimization LSTM neurons</title>
    <url>/2021/04/01/GA/</url>
    <content><![CDATA[<p><img src="/images/3_1.jpg"> </p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract :"></a>Abstract :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">Long-Short Term Memory Network stands out from the financial sector due to its long-term memory predictability, however, the speed of subsequent operations is extremely slow, and the timeliness of the inability to meet market changes has been criticized. In this paper. Aiming at the shortcomings of the slow running of three gates in each neuron of LSTM in back propagation, we1 propose to use GA to optimize the internal weights of LSTM neurons to optimize the defect. In this experiment, GA optimization could not change the accuracy of the model, but it achieved better results than the original LSTM in terms of speed, and satisfied the demand of the future business field for rapid response to market changes in terms of timeliness.
</blockquote>
<h1 id="LSTM-Architecture"><a href="#LSTM-Architecture" class="headerlink" title="LSTM Architecture :"></a>LSTM Architecture :</h1><p>  <img src="/images/3_2.jpg"> </p>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results :"></a>Results :</h1><p> <img src="/images/3_3.jpg"> </p>
<h1 id="Innovation"><a href="#Innovation" class="headerlink" title="Innovation :"></a>Innovation :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">This paper proposes a GA optimization method for LSTM neurons. By comparing the running time of predecessor models, it is possible to overcome the shortcomings of slow operation of LSTM to a certain extent by optimizing the internal weight of neurons through GA update.
<p style="text-align:justify; text-justify:inter-ideograph; color:black"> In addition, this article does not discuss the generalization ability of the network and other parameters of the network at the same time. The research purpose is too single. However, for the short-term prediction of financial markets, the importance of research on the timeliness and advancing of the model is much higher than that of the generalized network model
</blockquote>
<hr>
<h1 id="Publish"><a href="#Publish" class="headerlink" title="Publish :"></a>Publish :</h1><h3 id="Conference-2018-2nd-International-Conference-on-Deep-Learning-Technologies"><a href="#Conference-2018-2nd-International-Conference-on-Deep-Learning-Technologies" class="headerlink" title="Conference : 2018 2nd International Conference on Deep Learning Technologies"></a>Conference : 2018 2nd International Conference on Deep Learning Technologies</h3><h3 id="Index-EI-Compendex-Scopus"><a href="#Index-EI-Compendex-Scopus" class="headerlink" title="Index : EI Compendex, Scopus"></a>Index : EI Compendex, Scopus</h3><p><img src="/images/3_4.jpg"> </p>
<h1 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration :"></a>Declaration :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph;color:black;font-size:20px"> This paper was published a long time ago, and it is not perfect from my current point of view.<br>
<p style="text-align:right;color:black;font-size:20px"> --&nbsp;Moule Lin </blockquote>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>Object detection algorithm based AdaBoost residual correction Fast R-CNN on network</title>
    <url>/2021/04/01/odfr/</url>
    <content><![CDATA[<p><img src="/images/4_1.jpg"> </p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract :"></a>Abstract :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">The rapid development of computer hardware has promoted the prosperity of computer vision. Target object detection is widely used in various industrial and commercial fields, and contour detection is the core of target object detection. In order to realize the object target contour recognition method based on computer vision with high accuracy, this paper takes the cattle face position determination as an example, Fast R-CNN as the object contour detection algorithm, and uses AdaBoost as the residual detector to improve the accuracy of the results. In the experiment, the LabelImg tool marks the positional coordinates of the facial contours of 1000 cows, and at the same time, SURF algorithm was used to extract image features. The AdaBoost cascade classifier trained 900 positive images and 100 negative images. Fast R-CNN used the original images and the labeled images as training sets respectively. The results show that in the image set with resolution of 866*652 (pixels), the target detection accuracy of using Fast R-CNN is 91.6%, and AdaBoost as the residual detector will improve the accuracy to 96.76%. Meanwhile, by comparing the two training data sets of Fast r-cnn, the image labeled by LabelImg is used as the Fast r-cnn training set to obtain the optimal accuracy of 96.9% and the optimal recognition time of single picture of 0.35s.
</blockquote>
<h1 id="Image-Label"><a href="#Image-Label" class="headerlink" title="Image Label :"></a>Image Label :</h1><p>  <img src="/images/4_2.jpg"> </p>
<h1 id="Reslut"><a href="#Reslut" class="headerlink" title="Reslut :"></a>Reslut :</h1><p>  <img src="/images/4_3.jpg">  </p>
<hr>
<h1 id="Publish"><a href="#Publish" class="headerlink" title="Publish :"></a>Publish :</h1><h3 id="Conference-2019-3nd-International-Conference-on-Deep-Learning-Technologies"><a href="#Conference-2019-3nd-International-Conference-on-Deep-Learning-Technologies" class="headerlink" title="Conference : 2019 3nd International Conference on Deep Learning Technologies"></a>Conference : 2019 3nd International Conference on Deep Learning Technologies</h3><h3 id="Index-EI-Compendex-Scopus"><a href="#Index-EI-Compendex-Scopus" class="headerlink" title="Index : EI Compendex, Scopus"></a>Index : EI Compendex, Scopus</h3><p><img src="/images/4_4.jpg"> </p>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>Detect</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉熵损失函数详解</title>
    <url>/2020/11/02/crossentropy/</url>
    <content><![CDATA[<h1 id="交叉熵的数学原理—pytorch中的CrossEntropyLoss-函数"><a href="#交叉熵的数学原理—pytorch中的CrossEntropyLoss-函数" class="headerlink" title="交叉熵的数学原理—pytorch中的CrossEntropyLoss()函数"></a>交叉熵的数学原理—pytorch中的CrossEntropyLoss()函数</h1><p>对于二分类来说，我们使用的是Binary Cross Entropy Loss,公式如下：<br> <img src="/images/1_1.png"><br>因为ln后的数为负数，所以加负号，保证我们是优化最小（不然就要往最大值优化了）；<br>如当l=1时（标签为正样本），此时Loss = -logp, 我们要使p的值尽量大，loss才会尽量小，最好能到1，就代表分类正确了</p>
<h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><p><img src="/images/1_2.png"><br>这里的label会被展开为<strong>one-hot</strong>编码<br><strong>主要讨论图像像素级的分类</strong></p>
<pre><code># -*- coding: utf-8 -*-
&#39;&#39;&#39;
@File  : 多分类.py
@Author: Moule Lin
@Date  : 2020/11/1 17:53
@Github: https://github.com/moulelin
&#39;&#39;&#39;

&#39;&#39;&#39;
CrossEntropy 的原理
Pytorch中CrossEntropyLoss()函数的主要是将softmax-log-NLLLoss合并到一块得到的结果。

1、Softmax后的数值都在0~1之间，所以ln之后值域是负无穷到0。

2、然后将Softmax之后的结果取log，将乘法改成加法减少计算量，同时保障函数的单调性 。

3、NLLLoss的结果就是把上面的输出与Label对应的那个值拿出来(下面例子中就是：
将log_output\logsoftmax_output中与y_target对应的值拿出来)，去掉负号，再求均值。 
    
    Tip: CrossEntropyLoss() 会把Label变成ont-hot形式

&#39;&#39;&#39;
import torch
import torch.nn as nn


loss = nn.CrossEntropyLoss()# 使用默认参数
input_data = torch.randn(1,3,2,2,requires_grad=True) # 第一维度对应channel，CrossEntropy是针对channel进行的
target = torch.tensor([[0, 1],[2, 0]],dtype=torch.long).unsqueeze(0) # 对应2*2大小的矩阵，每个点都存在一个类别


print(input_data)

print(target.shape)
print(input_data.shape)
loss_item = loss(input_data,target)
print(loss_item)
# 上面是直接通过Cross Entropy，下面一步步实现


softmax_func=nn.Softmax(dim=1) # 将channel维度进行压缩到0-1
softmax_out = softmax_func(input_data)

print(&quot;经过softmax如下所示：&quot;)
print(softmax_out)
print(&quot;经过log如下所示：&quot;)
log_output=torch.log(softmax_out) # 取对数
print(log_output)

print(&quot;经过NLLLoss如下所示：&quot;)
nllloss_func=nn.NLLLoss()
nlloss_output=nllloss_func(log_output,target)
print(nlloss_output)

# import math
# loss = nn.CrossEntropyLoss()
# data = torch.randn(1,3,1,5,requires_grad=True)
# label = torch.empty((1,1,5),dtype=torch.long).random_(5)
# out = loss(data,label)
# print(data.shape)
# print(label.shape)
# print(out)
</code></pre>
<h3 id="输出如下："><a href="#输出如下：" class="headerlink" title="输出如下："></a>输出如下：</h3><pre><code>tensor([[[[-0.2493, -0.9333],
          [ 0.0676,  1.2035]],

         [[ 0.2987, -0.6044],
          [-0.1341,  0.0938]],

         [[-1.3529, -0.2693],
          [-0.3259, -0.7915]]]], requires_grad=True)
torch.Size([1, 2, 2])
torch.Size([1, 3, 2, 2])
tensor(0.9862, grad_fn=&lt;NllLoss2DBackward&gt;)
经过softmax如下所示：
tensor([[[[0.3266, 0.2308],
          [0.4013, 0.6823]],

         [[0.5650, 0.3207],
          [0.3280, 0.2249]],

         [[0.1083, 0.4484],
          [0.2707, 0.0928]]]], grad_fn=&lt;SoftmaxBackward&gt;)
经过log如下所示：
tensor([[[[-1.1189, -1.4660],
          [-0.9131, -0.3823]],

         [[-0.5709, -1.1371],
          [-1.1148, -1.4921]],

         [[-2.2225, -0.8020],
          [-1.3066, -2.3773]]]], grad_fn=&lt;LogBackward&gt;)
经过NLLLoss如下所示：
tensor(0.9862, grad_fn=&lt;NllLoss2DBackward&gt;)
</code></pre>
<blockquote>
<p>这里一共有四个像素点,分别是[[0, 1],[2, 0]]，对于第一个像素点来说，它的分类结果是0，输出为3类，即分为三类，所以会被展开为[1,0,0]<br>代表第一个元素的第0个通道上的数值是我想取出来的，这里就是-1.1189，同理，对于第二个像素点来说展开为[0，1，0]，取得-1.1371，第三个[0,0,1],取得-1.3066，第四个[1,0,0],取得-0.3823， 将这四个数取绝对值相加再除4，（1.1189+1.1371+1.3066+0.3823）/4 = 0.9862<br>所以说，对于一个图像来说，输入维度为B,C,W,H，label对应的维度就是B,1,W,H就可以</p>
</blockquote>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>English-Sentences</title>
    <url>/2021/11/01/English-Sentences/</url>
    <content><![CDATA[<h1 id="Some-sentences-autumn-break"><a href="#Some-sentences-autumn-break" class="headerlink" title="Some sentences autumn break"></a>Some sentences autumn break</h1><pre><code>We&#39;ll take a look some
That is where English comes in
English is no exception
Have come up with 提出
Rushed
Discover
How can I ever repay you
Don’t beat around the bush
explaining
easier said than done
don&#39;t judge a book by its cover

It is fair to say ~~
Keep up to
But out of all the available methods
Density noun
Destined adj
Be slowed down
Over here
lies ahead
Would I be talking about something
Hopefully soon
take a close look 我们仔细看看
small talk  闲聊
Between people and involoved
There are many popular topics of conversation when it comes using small-talk
Isn&#39;t it a lovely weather
We are having these day
Forecast
Reasons being

throw the book at sb 狠狠责罚（某人） ；给……以最严厉的惩罚

If no one has anything else to add, let’s wrap up the meeting

定冠词后接形容词表示同一类人或物或抽象概念，作主语谓语复数

who和whom的区别和he和him的区别是一样：
who可以理解为主格，做主语；whom可以理解为宾格，做宾语。
To whomcan we turn in case of an emergence?
注意：介词后一定要用whom:
可用who代替whom：
Whocame to the party last night?
昨晚都谁来参加聚会了？
Who/Whomare you going to invite to your party?
You have great taste in furniture
I really like what you have done with this house
Stylish == fashionable

</code></pre>
<hr>
<blockquote>
<p>While perhaps not as popular as CSS selectors, XPath expressions offer more power because besides navigating the structure, it can also look at the content.</p>
</blockquote>
<pre><code>While perhaps not as popular as CSS selectors, XPath expressions offer more power because besides navigating the structure, it can also look at the content.

The best way to learn is with examples, and Scrapy is no exception.

had better
1. 意思是“应该；最好”;
You had better study hard for your entrance exam.
You had better see the doctor about your cough.
2. 后接不带 to 的不定式：had better do sth;
you had better be careful.
It’s five o’clock. I’d better go now before the traffic gets too bad.
3.其用法相当于情态动词，动词 had 没有人称或数的变化。
She’d better get here soon or she’ll miss the opening ceremony.
4.常用来提出建议，语气较强，我们一般强调如果不这样做会有不好的后果。
或表示迫切的希望，警告等。
We&#39;d better take something to eat or we will be hungry later.
You had better lock the door before you leave.
You had better unplug the toaster before you try to clean it.
</code></pre>
<h1 id="被动"><a href="#被动" class="headerlink" title="被动"></a>被动</h1><blockquote>
<p>主动态表示句子的主语是行为的发生者或执行者。被动态表示句子的主语是行为的承受者。如果需要体现动作的发生者，需要借助by，谓语的时态要用“be的相应时态+过去分词”的来表。<br>看不懂没关系，给个例子就懂了。<br>[举例]过去时态下的被动语态<br>主动态：The teacher gave me the book.<br>被动态：I was given the book by the teacher.<br>从这个例子中可以看出，老师给我一本书，老师是动作的发生者，我是动作的承受者。所以在主动态中，主谓宾依次排放。<br>但当在被动态中。宾语放在了名首，所以宾语要承担动作。谓语就要发生相应的变化。由原来的gave改变为was given（记忆法：被动态中，一般现在时is/are + done，过去时was/were + done，将来时 shall/will be + done）。<br>[举例]现在完成时态下的被动语态<br>主动态：We have finished our work.<br>被动态：Our work has been finished.<br>（记忆法：被动态中，现在完成时has/have been + done，过去完成时had been + done，将来完成时 shall/will have been + done）。<br>学到这里，不知大家有没有注意到，have been done 又出现了。与今天主题句They have been married for more than 10 years.中have been married的句型完全一样。所以主题句使用的是被动句？<br>答案是：否，这也是大家在学习被动句后，特别要注意的一点。<br>●“be + 过去分词”不一定就是被动态<br>[例句]<br>The glass plate is broken. 这玻璃板是破的。（作表语）<br>The glass plate was broken by him. 这玻璃板（当时）被他打碎了。（被动态）<br>[例句]<br>The book is written well. 这本书写得很好。（作表语）<br>The book has been written by our teacher. 这本书已经由我们的老师写成。（被动态）<br>拿今天的主题句来进行解析。<br>They have been married for more than 10 years.<br>简短点来说“他们结婚了”<br>They are married.<br>“他们已经结婚了”<br>They have been married.<br>所以今日主题句的句型属于表语形式，并不是被动态哦。</p>
</blockquote>
<h1 id="words"><a href="#words" class="headerlink" title="words"></a>words</h1><blockquote>
<p>examine<br>scar scary scarf (scare v)<br>apparnently, the two things that people are most afraid of<br>when it comes to making a speech<br>used to do和be used to doing的含义不同，be used to doing表达习惯于做某事的意思；used to所表示的意思是“过去常常做某事”，强调过去发生的事，所以一般用于描述发生在过去的事情。<br>Get used to ：开始习惯于（从不习惯到习惯的一个过程）</p>
</blockquote>
<p>用法：Get used to V-ing/sth</p>
<p>这里的to也是充当介词，因此后面要有动名词或者名词</p>
<p>The food here is not so tasty but you will get used to that.</p>
<p>这里的伙食不怎么样，但你会慢慢习惯的。</p>
<p>Be used to doing和get used to doing主要的不同在于时间节点上，be used to doing一般是用在习惯之后，是”已经“习惯了，而get used to doing是习惯之前，”还没“习惯，要花时间去习惯，下面这个例句应该可以很好地说明两个词组的区别。</p>
<p>Tom wasn’t used to noise. It took him some time to get used to it.<br>I am well on the way to improving vocal technique<br>get accustomed<br>use you body as a way of making the speech more vivid and clear<br>gestures</p>
<pre><code>fantastic
fascinating
</code></pre>
<blockquote>
<p>usage</p>
</blockquote>
<pre><code>quite : The preformance is quite well
quiet : They lead a quiet life
</code></pre>
<pre><code> generous
 gorgeous
 prosperous
 prestigious
</code></pre>
<pre><code>corn
scorn
concorn
</code></pre>
<pre><code> delicate
 dedicate
 deduce
 
</code></pre>
<blockquote>
<p>virtue virus</p>
</blockquote>
<blockquote>
<p>stimulate 刺激 imitate 模仿</p>
</blockquote>
<blockquote>
<p>There is no viable alterntive</p>
</blockquote>
<blockquote>
<p>where have you been<br>where did you just go</p>
</blockquote>
<blockquote>
<p>it has been tow months since I arrived the Budapest<br>so-called<br>we examine the sacry process<br>crowd<br>of them all 表示其中一个或几个<br>all of them 表示所有<br>off to 将要去</p>
</blockquote>
<blockquote>
<p>how come 为什么；怎么会这样</p>
</blockquote>
<blockquote>
<p>how come是美国人常用的表达，意思是怎么会、为什么会这样。外国人不用how come表示怎么来的，怎么来的我们可以说，how do you get here。</p>
</blockquote>
<blockquote>
<p>how come的意思和why基本一致，但又有几点区别。</p>
</blockquote>
<pre><code>①how come一般适用于发生了什么事的场合。别人对你说how come，表示他不理解事情是怎么发生的，很希望得到你的解释。相比why，how come可以表达好奇和震惊的心情，语气要更加强烈。

②同时，how come更口语化，多用于生活交际。而why书面和口语都可以使用，使用范围更广。

③还有一个很重要的区别，大家千万要记住，why后面接的是疑问句，但是how come后面接的是陈述句的语序，千万不要搞错了。
</code></pre>
<blockquote>
<p>while others will hardly ever laugh at all<br>Have you ever been caught </p>
</blockquote>
<p><img src="/images/y-1.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy</title>
    <url>/2021/10/31/scrapy/</url>
    <content><![CDATA[<h2 id="span如果中间夹了其他的span。比如"><a href="#span如果中间夹了其他的span。比如" class="headerlink" title="span如果中间夹了其他的span。比如"></a>span如果中间夹了其他的span。比如</h2><pre><code>&lt;span&gt; &lt;span&gt;aa &lt;/span&gt; &lt;span&gt;bb &lt;/span&gt;cc&lt;/span&gt;
</code></pre>
<blockquote>
<p>adpote [-1] to acquire “cc” if I want to get it instead of text() directly<br>amount4 = ingredient.xpath(‘span[@class=”recipe__list-qty”]/text()’)[-1].get()</p>
</blockquote>
]]></content>
      <tags>
        <tag>spacpy</tag>
      </tags>
  </entry>
  <entry>
    <title>oral_practices</title>
    <url>/2021/11/01/oral-practices/</url>
    <content><![CDATA[<p>a new way to get personalized, relevant ideas, delivered right to your inbox.</p>
]]></content>
  </entry>
  <entry>
    <title>3D-python</title>
    <url>/2021/11/02/3D-python/</url>
    <content><![CDATA[<h1 id="plot-3D-by-python"><a href="#plot-3D-by-python" class="headerlink" title="plot 3D by python"></a>plot 3D by python</h1>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MATI-Regression</title>
    <url>/2021/11/02/MATI-Regression/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/MATI-Regression.pdf" width="100%" height="550" type="application/pdf">
	</div>




<h1 id="L1-amp-L2-regularization"><a href="#L1-amp-L2-regularization" class="headerlink" title="L1 &amp; L2 regularization"></a>L1 &amp; L2 regularization</h1>

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/MATI-Regression.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>MTAI</tag>
      </tags>
  </entry>
  <entry>
    <title>3D</title>
    <url>/2021/11/05/3D/</url>
    <content><![CDATA[<!-- Do you need some help for 3D?
I skipped some lectures, so first of all I need to rewatch that. After that, I will ask some help, thanks 
aassigments
I will try figure out by myself, then i will ask sometjiogn  -->
<blockquote>
<p>trangulation<br>tip: e2（第二个图像的极点是第一个图片的focal（焦点）在第二个坐标系下的投影），e2 = K’[R T][0,0,0,1]T([0,0,0,1]是第一个图片的坐标原点（世界坐标系的原点）)<br>问题一：为什么要进行相机标定？<br>相机标定的目的是：建立相机成像几何模型并矫正透镜畸变。这句话有点拗口，下面分别对其中两个关键部分进行解释。</p>
</blockquote>
<blockquote>
<p>建立相机成像几何模型：计算机视觉的首要任务就是要通过拍摄到的图像信息获取到物体在真实三维世界里相对应的信息，于是，建立物体从三维世界映射到相机成像平面这一过程中的几何模型就显得尤为重要，而这一过程最关键的部分就是要得到相机的内参和外参（后续文有具体解释）。</p>
</blockquote>
<blockquote>
<p>矫正透镜畸变：我们最开始接触到的成像方面的知识应该是有关小孔成像的，但是由于这种成像方式只有小孔部分能透过光线就会导致物体的成像亮度很低，于是聪明的人类发明了透镜。虽然亮度问题解决了，但是新的问题又来了：由于透镜的制造工艺，会使成像产生多种形式的畸变，于是为了去除畸变（使成像后的图像与真实世界的景象保持一致），人们计算并利用畸变系数来矫正这种像差。虽然理论上可以设计出不产生畸变的透镜，但其制造工艺相对于球面透镜会复杂很多，所以相对于复杂且高成本的制造工艺，人们更喜欢用数学来解决问题。</p>
</blockquote>
<p>相机成像模型<br>前面已经说过，相机标定的目的之一是为了建立物体从三维世界到成像平面上各坐标点的对应关系，所以首先我们需要定义这样几个坐标系来为整个过程做好铺垫：</p>
<blockquote>
<p>世界坐标系(world coordinate system)：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。</p>
</blockquote>
<blockquote>
<p>相机坐标系(camera coordinate system)：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位为m。</p>
</blockquote>
<blockquote>
<p>图像坐标系(image coordinate system)：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 单位为m。</p>
</blockquote>
<blockquote>
<p>像素坐标系(pixel coordinate system)：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。单位为个（像素数目）。</p>
</blockquote>
<p>一下子定义出来四个坐标系可能有点晕，下图可以更清晰地表达这四个坐标系之间的关系：<br><img src="/images/3D-1.jpeg"></p>
<h2 id="世界坐标系：Xw、Yw、Zw。相机坐标系：-Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。"><a href="#世界坐标系：Xw、Yw、Zw。相机坐标系：-Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。" class="headerlink" title="世界坐标系：Xw、Yw、Zw。相机坐标系： Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。"></a>世界坐标系：Xw、Yw、Zw。相机坐标系： Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。</h2><blockquote>
<p>其中，相机坐标系的z轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点，相机坐标系与图像坐标系之间的距离为焦距f（也即图像坐标系原点与焦点重合）。像素坐标系平面u-v和图像坐标系平面x-y重合，但像素坐标系原点位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。<br><img src="/images/3D-2.jpeg"><br>下面将依次对刚体进行一系列变换，使之从世界坐标系进行仿射变换、投影透射，最终得到像素坐标系下的离散图像点，过程中会逐步引入各参数矩阵。</p>
</blockquote>
]]></content>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>pronounce</title>
    <url>/2021/11/06/pronounce/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/pronounce.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>pronounce</tag>
      </tags>
  </entry>
  <entry>
    <title>BPR推荐算法</title>
    <url>/2021/11/16/BPR/</url>
    <content><![CDATA[<p><img src="/images/BPR.png"> </p>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>BRP推荐算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Theory</title>
    <url>/2021/12/01/Theory/</url>
    <content><![CDATA[<h1 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h1>

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/probability.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
  </entry>
  <entry>
    <title>Hierarchical</title>
    <url>/2021/12/02/Hierarchical/</url>
    <content><![CDATA[<blockquote>
<p>层次聚类算法 各种linkage</p>
</blockquote>
<p>基本工作原理<br>给定要聚类的N的对象以及N*N的距离矩阵(或者是相似性矩阵), 层次式聚类方法的基本步骤(参看S.C. Johnson in 1967)如下:</p>
<ol>
<li><pre><code>将每个对象归为一类, 共得到N类, 每类仅包含一个对象. 类与类之间的距离就是它们所包含的对象之间的距离.
</code></pre>
</li>
<li><pre><code>找到最接近的两个类并合并成一类, 于是总的类数少了一个.
</code></pre>
</li>
<li><pre><code>重新计算新的类与所有旧类之间的距离.
</code></pre>
</li>
<li><pre><code>重复第2步和第3步, 直到最后合并成一个类为止(此类包含了N个对象).
</code></pre>
<p>根据步骤3的不同, 可将层次式聚类方法分为几类: single-linkage, complete-linkage 以及 average-linkage 聚类方法等.</p>
</li>
</ol>
<p>single-linkage 聚类法(也称 connectedness 或 minimum 方法)：</p>
<p>类间距离等于两类对象之间的最小距离，若用相似度衡量，则是各类中的任一对象与另一类中任一对象的最大相似度。</p>
<p>complete-linkage 聚类法 (也称 diameter 或 maximum 方法)：</p>
<p>组间距离等于两组对象之间的最大距离。</p>
<p>average-linkage 聚类法：</p>
<p>组间距离等于两组对象之间的平均距离。</p>
<p>average-link 聚类的一个变种是R. D’Andrade (1978) 的UCLUS方法, 它使用的是median距离, 在受异常数据对象的影响方面, 它要比平均距离表现更佳一些.</p>
<p>这种层次聚类称为“凝聚”法，由于它迭代合并所有分类。也有一种“划分”层次聚类法，与“凝聚”相反，它先将所有对象放在同一类中，并不断划分成更小的类，划分法一般很少使用。</p>
<p>整个聚类过程其实是建立了一棵树，在建立的过程中，可以通过在第二步上设置一个阈值，当最近的两个类的距离大于这个阈值，则认为迭代可以终止。另外关键的一步就是第三步，如何判断两个类之间的相似度有不少种方法。这里介绍一下三种：</p>
<p>SingleLinkage：又叫做 nearest-neighbor ，就是取两个类中距离最近的两个样本的距离作为这两个集合的距离，也就是说，最近两个样本之间的距离越小，这两个类之间的相似度就越大。容易造成一种叫做 Chaining 的效果，两个 cluster 明明从“大局”上离得比较远，但是由于其中个别的点距离比较近就被合并了，并且这样合并之后 Chaining 效应会进一步扩大，最后会得到比较松散的 cluster 。</p>
<p>CompleteLinkage：这个则完全是 Single Linkage 的反面极端，取两个集合中距离最远的两个点的距离作为两个集合的距离。其效果也是刚好相反的，限制非常大，两个 cluster 即使已经很接近了，但是只要有不配合的点存在，就顽固到底，老死不相合并，也是不太好的办法。这两种相似度的定义方法的共同问题就是指考虑了某个有特点的数据，而没有考虑类内数据的整体特点。</p>
<p>Average-linkage：这种方法就是把两个集合中的点两两的距离全部放在一起求一个平均值，相对也能得到合适一点的结果。</p>
<p>average-linkage的一个变种就是取两两距离的中值，与取均值相比更加能够解除个别偏离样本对结果的干扰。</p>


	<div class="row">
    <embed src="https://moulelin.github.io/pdf/cluster.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>culster</tag>
      </tags>
  </entry>
  <entry>
    <title>silhouette</title>
    <url>/2021/12/04/silhouette/</url>
    <content><![CDATA[<p><img src="/images/silhouette.png"> </p>
]]></content>
      <tags>
        <tag>intr</tag>
      </tags>
  </entry>
  <entry>
    <title>to+do+or+doing</title>
    <url>/2021/12/12/to-do-or-doing/</url>
    <content><![CDATA[<p><img src="/images/todo.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>likeihood</title>
    <url>/2021/12/17/likeihood/</url>
    <content><![CDATA[<p><img src="/images/likelihood.png"> </p>
]]></content>
      <tags>
        <tag>likelihood</tag>
      </tags>
  </entry>
  <entry>
    <title>英语句子</title>
    <url>/2021/12/22/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90/</url>
    <content><![CDATA[<blockquote>
<p>commence—Many people have wondered why the end of someone’s school days should be celebrated by Commencement Exercises, which, ordinarily, refer to a beginning</p>
</blockquote>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>emotion_behind_your_money_habits</title>
    <url>/2021/12/24/emotion-behind-your-money-habits/</url>
    <content><![CDATA[<blockquote>
<p>I’m good with numbers and using them to report what’s happening, but I’m also concerned with the full story behind those numbers, the part that gets lost in translation, the part that numbers can’t quite tell, the story that goes deeper than mere stratetgies for saving and earning money.</p>
</blockquote>
<p><img src="/images/emotional.png"> </p>
]]></content>
      <tags>
        <tag>ted</tag>
      </tags>
  </entry>
  <entry>
    <title>过去式</title>
    <url>/2021/12/25/%E8%BF%87%E5%8E%BB%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="过去式变化规则"><a href="#过去式变化规则" class="headerlink" title="过去式变化规则"></a>过去式变化规则</h1><p>1）动词过去式变化规则分为规则变化和不规则变化两种，一般情况下，动词原形词尾加-ed，以不发音的-e结尾动词，动词词尾加-d，以辅音字母+y结尾的动词，把-y变为-i 再加-ed<br>2）以一个元音+一个辅音字母结尾的重读闭音节动词，双写词尾辅音字母，否则就加ed<br>preFER-&gt;preFERRed<br>VISit-&gt;VISited<br>3）不满足一个元音+一个辅音结尾 + ed<br>start-&gt;started 两个辅音结尾<br>need-&gt;needed<br>3) 一个元音+y +ed<br>stay-&gt;stayed</p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>self-attention</title>
    <url>/2022/01/02/self-attention/</url>
    <content><![CDATA[<p><img src="/images/attention.png"> </p>
]]></content>
      <tags>
        <tag>attention</tag>
      </tags>
  </entry>
  <entry>
    <title>transformer</title>
    <url>/2022/01/02/transformer/</url>
    <content><![CDATA[<p><img src="/images/transformer.png"> </p>
]]></content>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>TF-IDF</title>
    <url>/2022/01/04/TF-IDF/</url>
    <content><![CDATA[<p><img src="/images/TF-IDF.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>transition-based</title>
    <url>/2022/01/04/transition-based/</url>
    <content><![CDATA[<p><img src="/images/transition.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2022/01/04/word2vec/</url>
    <content><![CDATA[<p><img src="/images/word2vec.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>n-gram</title>
    <url>/2022/01/04/n-gram/</url>
    <content><![CDATA[<p><img src="/images/n-gram.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>DBSCAN</title>
    <url>/2022/01/06/DBSCAN/</url>
    <content><![CDATA[<p><img src="/images/DBSCAN.png"> </p>
]]></content>
      <tags>
        <tag>DBSCAN</tag>
      </tags>
  </entry>
  <entry>
    <title>apriori</title>
    <url>/2022/01/06/apriori/</url>
    <content><![CDATA[<p><img src="/images/apriori.png"> </p>
]]></content>
      <tags>
        <tag>apriori</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/2022/01/13/C/</url>
    <content><![CDATA[<blockquote>
<p>静态函数不能访问非静态变量<br>static method cannot access non-static variables<br>静态函数不会被实例化（不存在对象），就像是写在类外部的函数一样</p>
</blockquote>
<pre><code>static void Print(classname e)&#123;

    std::cout&lt;&lt;e.x &lt;&lt; std::endl;
&#125;
&#39;&#39;&#39;
&gt;临时变量作为非const的引用进行参数传递引发的编译错误_mlove编程-程序员宝宝
技术标签： QT  qt  string  linux  

1.错误原因即解决办法
Linux环境运行，使用g++编译，观察如下代码，会出现： invalid initialization of non-const reference of type ‘std::string&amp;’ from a temporary of type ‘std::string’的错误。

其中文意思为临时变量无法为非const的引用初始化。也就是在参数传递的过程中，出现错误。出错的代码如下
</code></pre>
<p>void print(string&amp; str)<br>{<br>    cout&lt;&lt;str&lt;&lt;endl;<br>}<br>//如此调用会报上面描述的错误</p>
<pre><code>print(&quot;hello world&quot;);


出错的原因是编译器根据字符串”hello world”构造一个string类型的临时对象，这个临时对象具有const属性。当这个临时对象传递给非const的string&amp;引用类型时，因为非const引用绑定对象时，要求该对象也是非const对象。而在这时，因为string类型的临时对象是const对象，所以就出现错误。因此，解决办法就是将print()函数的参数改为常引用。代码修改如下，可顺利通过编译。

void print(const string&amp; str)
&#123;
    cout&lt;&lt;str&lt;&lt;endl;
&#125;
//顺利通过编译
print(&quot;hello world&quot;);
通过以上代码，也可以看出Effective C++中倡导的一个C++的编程原则，即尽可能的使用const。因为这样可以使代码更为健壮，将错误暴露于编译阶段。

2.所有的临时对象都是const对象吗
为什么临时对象作为引用参数传递时，必须是常量引用呢？很多人对此的解释是临时对象是常量，不允许赋值改动，所以作为非常量引用传递时，编译器就会报错。这个解释在关于理解临时对象不能作为非const引用参数这个问题上是可以的，但不够准确。更有甚者，认为所有的临时对象均是const对象，因此，对于网上的观点和资源我们应该持着谨慎怀疑的态度去接受学习，应该坚持鲁迅先生倡导的”拿来主义”，应该批判参考和借鉴。

事实上，临时变量是可以被作为左值(LValue) 并被赋值的，请看下面的代码：

class IntClass&#123;
private:
    int x;
public:
    IntClass(int value):x(value)&#123;
    &#125;

    friend  ostream&amp; operator&lt;&lt;( ostream &amp;os, const IntClass &amp;intc);
&#125;;

//重载输出operator&lt;&lt;
ostream&amp; operator&lt;&lt;( ostream &amp;os, const IntClass &amp;intc)
&#123;
    os&lt;&lt;intc.x;
    return os;
&#125;

//打印函数
void print(IntClass &amp; intc)
&#123;
    cout&lt;&lt;intc&lt;&lt;endl;
    //通过引用修改这个临时对象
    intc=8;
    cout&lt;&lt;intc&lt;&lt;endl;
&#125;

int main(int argc,char* argv[])
&#123;
    print(IntClass(6));
&#125;
程序输出：
6
8

以上代正确编译运行，没有错误。IntClass(6)表示生成一个无名的临时对象，传递给非const引用，在print函数中通过引用修改了这个临时对象。这说明了并非所有的临时对象都是const对象。

那哪些临时对象是const对象，哪些临时对象不是const对象呢？这里贴上摘自网上的一句话：“内置类型产生的临时变量具有常性，而自定义类型产生的临时变量不具有常性”，我想这句话能解释你所谓的临时变量为什么能作为左值的原因。

int* const a = new int;
这个不能修改指针a, 如 a = &amp;b; 报错
const int* a = new int; int const* a = new int; 这两个相同，看const的位置
这个不能修改指针a指向的内容， *a = 2; 报错 
</code></pre>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Homogeneous</title>
    <url>/2022/01/26/Homogeneous/</url>
    <content><![CDATA[<p><img src="/images/homogeneous.png"> </p>
]]></content>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>equilibria</title>
    <url>/2022/02/08/equilibria/</url>
    <content><![CDATA[<p><img src="/images/game01.png"> </p>
<p>举个例子吧如图所示：首先固定1<br>1选择C–&gt; 2最好选择C(-5&gt;-15)，<br>画上蓝色线条<br>1选择N–&gt; 2最好选择C(0&gt;-1)，画上蓝色线条<br>接下来固定2<br>2选择C–&gt; 1最好选择C(-5&gt;-15)，画上红色线条<br>2选择N–&gt; 1最好选择C(0&gt;-1)，画上红色线条得纯策略纳什均衡(-5,-5)</p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>VCDimension</title>
    <url>/2022/02/10/VCDimension/</url>
    <content><![CDATA[<blockquote>
<p>注意这里的VC维度指的是只要存在一个不可分的点，比如四个点，一条直线存在无法分割的情况，那就VC维度就不是4，应该从3来看<br><img src="/images/CVDim.png"> </p>
</blockquote>
]]></content>
      <tags>
        <tag>Machine</tag>
      </tags>
  </entry>
  <entry>
    <title>Likelihood2</title>
    <url>/2022/02/24/Likelihood2/</url>
    <content><![CDATA[<blockquote>
<p>注意：高斯分布图x轴坐标是变量X的取值，纵坐标是概率<br>因此，这里得到误差l（打不了误差符号），最大误差的密度概率是因为=》最大概率处l=0， 同时我们追求的也是误差最小，无限接近0，所以这里要对误差l的PDF取最大值，因此，每个样本的最大概率（最大似然）累乘就是我们需要优化的结果。<br><img src="/images/max.png"> </p>
</blockquote>
]]></content>
      <tags>
        <tag>Likelihood</tag>
      </tags>
  </entry>
  <entry>
    <title>smartpointer</title>
    <url>/2022/03/04/smartpointer/</url>
    <content><![CDATA[<p><img src="/images/smartPointer.png"> </p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>shardptrCirculate</title>
    <url>/2022/03/04/shardptrCirculate/</url>
    <content><![CDATA[<blockquote>
<p>定义对象用强智能指针，引用对象的时候用弱智能指针<br><img src="/images/shardptrcirculate.png">  </p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>subjunctive</title>
    <url>/2022/03/06/subjunctive/</url>
    <content><![CDATA[<h2 id="The-president-flanked-by-Secretary-of-State-John-Kerry-and-vice-President-Joe-Biden-down-played-the-claimed-economic-benefits-of-the-pipeline-arguing-it-wouldn’t-have-lowered-U-S-gas-prices-created-long-term-jobs-or-reduced-U-S-dependency-on-foreign-energy"><a href="#The-president-flanked-by-Secretary-of-State-John-Kerry-and-vice-President-Joe-Biden-down-played-the-claimed-economic-benefits-of-the-pipeline-arguing-it-wouldn’t-have-lowered-U-S-gas-prices-created-long-term-jobs-or-reduced-U-S-dependency-on-foreign-energy" class="headerlink" title="The president, flanked by Secretary of State John Kerry and vice President Joe Biden, down played the claimed economic benefits of the pipeline, arguing it wouldn’t have lowered U.S. gas prices, created long-term jobs or reduced U.S. dependency on foreign energy."></a>The president, flanked by Secretary of State John Kerry and vice President Joe Biden, down played the claimed economic benefits of the pipeline, arguing it wouldn’t have lowered U.S. gas prices, created long-term jobs or reduced U.S. dependency on foreign energy.</h2><blockquote>
<p>wouldn’t have done 表示不会做某事，但是实际上做了。文章中的意思是本来不会降低美国的油气价格。</p>
</blockquote>
<p>would have done</p>
<p>是一个固定虚拟语气的用法。</p>
<p>表示对过去事情的假设，意为“本来想做、要做但没做”，使用时大多会给出导致没做成或会这样做的条件。<br>英汉例句1：</p>
<p>If I had a chance，I would have set off on a journey round the world.<br>要是有机会，我早就环游世界了。（也可译为对现在的虚拟“要是有机会，我会环游世界”）</p>
<p>英汉例句2：</p>
<p>I would have told you the story about him, but you were not home.</p>
<p>我本来可以告诉你关于他的故事，但是你不在家。（由于：你不在家”这样的条件下，没有告诉关于他的的故事。）</p>
<p>5.would have done与if连用</p>
<p>例句：If I hadn’t been busy that day, I would have gone there with them.</p>
<p>如果那天我不忙，我会和他们一起去那儿。（事实上表示没有由于忙，而没有去。）</p>
<p>在这里也可以不用if</p>
<p>如：I was busy that day. Otherwise I would have gone there with them. </p>
<p>我那天很忙，否则，我就和他们一起去那儿了。</p>
<p>6.文章中lower 在这里作为动词，“降低”的意思。<br><img src="/images/subjunctive.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>类内声明和定义</title>
    <url>/2022/03/10/%E7%B1%BB%E5%86%85%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>1.类内定义</p>
<pre><code>    类内定义的概念：成员函数的函数体（实现）是在类的内部完成的。这种实现方式c++隐式为内联函数。

   A.h
</code></pre>
<p>class A<br>{<br>public:<br>    A(void);<br>    virtual ~A(void);<br>    int test(){return 1;};<br>    int test1();<br>};<br>         可以看到类A中成员函数test()的定义在类的内部，隐式为内联函数（inline的原理，是用空间换取时间的做法，是以代码复制为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。所以，如果函数体代码过长或者函数体重有循环语句，if语句或switch语句或递归时，不宜用内联）。</p>
<p>2.类外定义</p>
<pre><code>   类外定义的概念:成员函数的定义是在类的外部实现的就像类A中的成员函数test1()，在类中只有声明。

   A.h
</code></pre>
<p>class A<br>{<br>public:<br>    A(void);<br>    virtual ~A(void);<br>    int test(){return 1;};<br>    int test1();<br>};<br>      A.cpp</p>
<p>#include “A.h”</p>
<p>A::A(void)<br>{<br>}<br>A::~A(void)<br>{<br>}<br>int A::test1()<br>{<br>    return 1;<br>}<br>     这种类外定义的方式属于分文件类外定义，声明和定义不在同一文件中，还有一种类外定义方式为同文件类外定义，声明和定义在同一个.cpp文件中。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2022/03/12/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>做个简单的比喻：进程=火车，线程=车厢线程在进程下行进（<br>单纯的车厢无法运行）一个进程可以包含多个线程（一辆火车可以有多个车厢）<br>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）<br>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）<br>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）<br>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）<br>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）<br>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>copyC</title>
    <url>/2022/03/13/copyC/</url>
    <content><![CDATA[<p>浅拷贝和深拷贝<br>指针浅拷贝导致堆区的数据重复释放<br>问题：近期在做算法实验的时候碰到一个关于类指针赋值的问题，简单的指针之间的赋值只是把两个指针指向同一个地址，而我需要把每次算法执行完的类指针push_back进vector储存每次算法迭代的结果，如果每次都是存入同一个指针，就会出现vector中的类指针都指向同一个地址，这就让我想到了能不能进行类指针之间的赋值，两个类指针之间内容相同，但是指针指向的地址都不同，就是两个不同的指针。</p>
<p>定义</p>
<p>浅拷贝：按照我的理解就是，两类之间发生数据成员的赋值，如果只是简单数据类型之间的赋值，浅拷贝完全能够胜任，但是碰到有指针的时候，两个类之间浅拷贝，那么两个对象中的指针会指向同一个地址，那么析构函数执行的时候就会发生错误（同一指针释放了两次）。</p>
<p>深拷贝：在浅拷贝的基础上对指针拷贝进行处理，让两个类指针中的指针指向不同的区域，这样两个类指针虽然内容想到，但是是存储在内存的不同区域。<br>‘’’<br>class rect<br>{<br>public:</p>
<pre><code>rect();
rect(const rect *r);
~rect();
</code></pre>
<p>private:<br>    int width, height;<br>    int *p;<br>};<br>rect::rect(const rect *r)<br>{<br>    width = r-&gt;width;<br>    height = r-&gt;height;<br>    p = new int;<br>    *p = *(r-&gt;p);<br>}</p>
<p>rect::rect()<br>{<br>    p = new int(100);<br>}</p>
<p>rect::~rect()<br>{<br>    if (p != NULL)<br>        delete p;<br>}<br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>    rect *rect1;<br>    rect *rect2;<br>    rect1 = new rect;<br>    rect2 = new rect(rect1);</p>
<pre><code>return 0;
</code></pre>
<p>}<br>‘’’<br>类指针和类内成员p指针都指向了不同的地址</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>operator赋值为什么返回引用</title>
    <url>/2022/03/13/operator%E8%B5%8B%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>一个自定义类，如果没有重载其=运算符，那么编译器将自动生成一个。但是此编译器自动生成的重载函数可能不安全。这是因为它采用了所谓的“浅拷贝”，也就是对于指针而言，它拷贝的是指针的值，而不是其指向的内存空间。那么这个内存空间就有了两个指针指向它，且类对象要析构两次，但是内存空间只能被释放一次，那么第二次就会出现访问错误。</p>
<p>　　要避免这种“浅拷贝”问题，就需要重载=运算符。这是一个二元运算符，函数名和参数比较容易确定，重点是其返回类型。一般来说，要返回一个类的引用类型。这是因为要能实现所谓的“链式编程”。我存在过的疑问是，为什么要返回一个引用，才能实现所谓的“链式编程”呢？这里从代码出发，进行思考与总结。</p>
<p>复制代码<br>class Student<br>{<br>public:<br>    Student(const char* name);~Student();<br>    Student&amp; operator=(const Student &amp;student);private:<br>    char *m_name;<br>};<br>复制代码<br>复制代码<br>//测试代码<br>Student s1(“Lee”);<br>Student s2(“Diwen”);<br>Student s3(“Tom”);</p>
<p>//先执行s2 = s1, 即执行 s2.operator=(s1), 返回的是s2的引用<br>//然后执行s3 = s2, 即执行 s3.operator=(s2)<br>s3 = s2 = s1;<br>复制代码<br>　　=的链式编程执行顺序是从右向左的。因此右边需要返回一个Student类型的对象，是肯定的。那么问题是，为何要返回一个引用呢？</p>
<p>　　观察一下重载=运算符的函数，参数类型是一个常量引用，也即是说传进去的实参必须是一个左值。而如果返回类型是Student，那么返回的就是一个匿名对象（右值），作为链式编程，此返回值（右值）又要作为实参传进去，那么显然不行(不加const不行，加了是可以的)。<br>const引用可以绑定到右值，而重载的赋值运算符返回一个引用当然是为了避免没有意义的拷贝了。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Monte</title>
    <url>/2022/03/17/Monte/</url>
    <content><![CDATA[<blockquote>
<p>引入概率密度函数的蒙特卡洛公式推导，是把p(x) 看作前面分数的密度概率函数，也就是对前面分数求期望，而期望可以通过对p（x）采样并平均得到<br><img src="/images/MCMC.png">  </p>
</blockquote>
]]></content>
      <tags>
        <tag>machine</tag>
      </tags>
  </entry>
  <entry>
    <title>DP</title>
    <url>/2022/03/18/DP/</url>
    <content><![CDATA[<p><img src="/images/DP.png">  </p>
]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>MC</title>
    <url>/2022/03/19/MC/</url>
    <content><![CDATA[<p><img src="/images/MC.png">  </p>
]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>RL3ways</title>
    <url>/2022/03/20/RL3ways/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/RL3.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>across_loss</title>
    <url>/2022/03/29/across-loss/</url>
    <content><![CDATA[<p><img src="/images/cross_derivate.png"> </p>
]]></content>
      <tags>
        <tag>machine</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplusnotes</title>
    <url>/2022/05/01/Cplusplusnotes/</url>
    <content><![CDATA[<blockquote>
<p>静态函数只能访问静态数据</p>
</blockquote>
<blockquote>
<p>为什么static成员变量一定要在类外初始化?</p>
</blockquote>
<pre><code>static变量属于类，非对象，如果在类内初始了，该类再一次创建对象将变成初始值，会修改其他对象对该静态变量操作的意图可能发生意外
但是
static const int a = 1;
这个可以在类内初始化，因为const说明这个变量是不变的，因此对于每个对象来说，static内存块的的数据就是一样的
</code></pre>
<h2 id="为什么静态成员不能在类内初始化？"><a href="#为什么静态成员不能在类内初始化？" class="headerlink" title="为什么静态成员不能在类内初始化？"></a>为什么静态成员不能在类内初始化？</h2><p>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。</p>
<p>class A<br>{<br>private:<br>static int count ; // 类内声明<br>};</p>
<ul>
<li><p>类外定义并初始化，不必再加static关键字<br>int A::count = 0 ;<br>或者只进行定义不赋初始值，但是默认值是否是0，可能会与具体的编译器有关吧？</p>
</li>
<li><p>只进行定义不赋初始值，但默认值视编译器而定<br>int A::count;<br>为什么？</p>
</li>
<li><p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p>
</li>
</ul>
<p>如果不增加int A::count = 0 ; //变量定义，在编译的时候将会报出：‘A::count’未定义的引用”错误。这是因为静态成员变量count未定义，也就是还没有分配内存，显然是不可以访问的。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>均方误差分解</title>
    <url>/2022/05/21/%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/images/biasAndvariance.png"> </p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>期望和方差</title>
    <url>/2022/05/21/%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE/</url>
    <content><![CDATA[<p><img src="/images/expectAndvariance.png"> </p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>forandrecursion</title>
    <url>/2022/04/21/forandrecursion/</url>
    <content><![CDATA[<blockquote>
<p>为什么要用for循环调用递归呢?<br>什么时候递归需要加一层for循环呢？</p>
</blockquote>
<h1 id="Answer：当子任务是被划分为-多层的子任务"><a href="#Answer：当子任务是被划分为-多层的子任务" class="headerlink" title="Answer：当子任务是被划分为  多层的子任务"></a>Answer：当子任务是被划分为  多层的子任务</h1><blockquote>
<p>比如全排列问题</p>
</blockquote>
]]></content>
      <tags>
        <tag>-algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>过拟合和欠拟合</title>
    <url>/2022/05/22/%E8%BF%87%E6%8B%9F%E5%90%88%E5%92%8C%E6%AC%A0%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<p><img src="/images/overfit.png"> </p>
]]></content>
      <tags>
        <tag>machine</tag>
      </tags>
  </entry>
  <entry>
    <title>transitions</title>
    <url>/2022/06/11/transitions/</url>
    <content><![CDATA[<h2 id="It’s-about-advance-transitions-in-English-writing"><a href="#It’s-about-advance-transitions-in-English-writing" class="headerlink" title="It’s about advance transitions in English writing."></a>It’s about advance transitions in English writing.</h2><p>object clause（宾语从句）</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><ul>
<li><a href="#Thereby">Thereby</a></li>
<li><a href="#Therein">Therein</a></li>
<li><a href="#Thereof">Thereof</a></li>
<li><a href="#Therefore">Therefore</a></li>
<li><a href="#Thereafter">Thereafter</a></li>
<li><a href="#Wherein">Wherein</a></li>
<li><a href="#Whereby">Whereby</a></li>
<li><a href="#Hereby">Hereby</a></li>
<li><a href="#Semicolon">Semicolon</a><br>so as to 为的是<h2 id="Thereby"><a href="#Thereby" class="headerlink" title="Thereby:"></a>Thereby:</h2><blockquote>
<p>The team lost the final game of the season, thereby <strong>missing</strong> the playoffs<br>(thereby : through the reason)</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Due to the team lost the final game of the season, they missed the palyoffs</p>
</blockquote>
<hr>
<blockquote>
<p>Lisa studied for three straight weeks and (Lisa) was <strong>thereby</strong> able to pass her test<br>(Because the reason of the last sentence and have result of the next sentence)</p>
</blockquote>
<blockquote>
<p>(Reproduce) : The ability to compound the spatial information of the CNN model exists some intractable bottlenecks and are thereby limiting the development of the AI</p>
</blockquote>
<hr>
<h2 id="Therein"><a href="#Therein" class="headerlink" title="Therein"></a>Therein</h2><p>(在其中)</p>
<blockquote>
<p>Therein lies the rub.───难就难在这里</p>
</blockquote>
<blockquote>
<p>The contract does not allow for extended maternity leave; therein lies the problem for the union, 60% of whose membership is young women<br>(合同不允许延长产假； 这就是工会的问题所在，60% 的会员是年轻女性)</p>
</blockquote>
<blockquote>
<p>The tomb, and all the contents therein(在坟墓的内容), were photographed before analysis could begin == The tomb and and all the contents were photographed before analysis could begin.<br>(加therein显得更academic)</p>
</blockquote>
<p>（这里的were代表前面是多个东西，需要保持consensus,所以需要加and，这里也是两个东西，用and连接; before这个介词比较特殊，后面可以加句子，比如：Please come to my house before you leave.<br>）</p>
<h2 id="Thereof"><a href="#Thereof" class="headerlink" title="Thereof"></a>Thereof</h2><p>thereof=of that thing mentioned earlier</p>
<blockquote>
<p>Fine wines, and a knowledge thereof (of wines) are a luxury few can afford</p>
</blockquote>
<p>（这是主语从句，一句话做主语的句子英语？<br>What he did made US surprised，这个句子就是一个主语从句做主语的例子<br>The bag i bought is too big.<br>What you see is what you get. 所见即所得。）</p>
<blockquote>
<p>We will focus on China, espeically its history and culture thereof (=of China).</p>
</blockquote>
<blockquote>
<p>Both parties had their sights foused on the northern regions, especially the demographics thereof, and were preparing for an ad wars</p>
</blockquote>
<h2 id="Therefore"><a href="#Therefore" class="headerlink" title="Therefore"></a>Therefore</h2><p>I am well-prepared, there is no reason, therefore, that I should stumble<br>(I am well-prepared. Therefore there is no reason that I should stumble)</p>
<h2 id="Thereafter"><a href="#Thereafter" class="headerlink" title="Thereafter"></a>Thereafter</h2><p>He worked at the university until he retired; thereafter, he took on sporadic work as a consultant.</p>
<h2 id="Wherein"><a href="#Wherein" class="headerlink" title="Wherein"></a>Wherein</h2><p>Wherein(in which); wherein=in which part</p>
<blockquote>
<p>It is not specified wherein (in which part) he violated the law.</p>
</blockquote>
<p>The affidavit did not implictly outline wherein Mr.Smith had broken any laws.</p>
<h2 id="Whereby"><a href="#Whereby" class="headerlink" title="Whereby"></a>Whereby</h2><p>whereby= by means of which/according to which</p>
<blockquote>
<p>a proposal whereby (according to the proposal) everyone has to learn Chinesea </p>
</blockquote>
<blockquote>
<p>a system whereby (by means of the system) you can learn Chinese everywhere</p>
</blockquote>
<blockquote>
<p>The company introduced a new incentive program whereby all employees were given an equal shot at the bonuses.</p>
</blockquote>
<h2 id="Hereby"><a href="#Hereby" class="headerlink" title="Hereby"></a>Hereby</h2><p> = caused by this (document)</p>
<blockquote>
<p>I hereby (affected by this situation) agree/submit…</p>
</blockquote>
<blockquote>
<p>Given the present circumstances, I hereby resign my post as CEO</p>
</blockquote>
<h2 id="Semicolon"><a href="#Semicolon" class="headerlink" title="Semicolon"></a>Semicolon</h2><blockquote>
<p>英文写作中如何使用分号(Semicolon)<br>在分隔两个独立的概念(两个独立的从句)时，我们使用分号，但前提是这两个句子是有相关性的。当陈列复杂的概念或短语，并且句中包含逗号时，适合使用分号来分隔。分号拥有逗号的功能，但包含更多意思，亦有冒号的功能，但在使用起来更加灵活。<br>在句中加入两个或多个概念，而这些概念互为平等时：</p>
</blockquote>
<p>The universe has always called to human beings; there could be no more final frontier than space.</p>
<blockquote>
<p>加入两个用连接副词或转折片语连接的独立从句：</p>
</blockquote>
<p>Sam thought David was inviting him to the picnic to enjoy a nice day out; as it turned out, David was planning a surprise birthday party.</p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>whom</title>
    <url>/2022/06/15/whom/</url>
    <content><![CDATA[<h2 id="What’s-different-between-who-and-whom"><a href="#What’s-different-between-who-and-whom" class="headerlink" title="What’s different between who and whom"></a>What’s different between who and whom</h2><blockquote>
<p>Put simply, use whom—which is a pronoun—when it is the object of a sentence. If you can replace the word with “her,” “him,” or “them” for example, use “whom.” You’ll know when to use “whom” if the pronoun is used in the objective case, or action is being done to the pronoun. Take the sentence:</p>
</blockquote>
<blockquote>
<p>Whom do you believe?</p>
</blockquote>
<blockquote>
<p>The sentence may sound pretentious, even snobbish. But it is correct because “whom” is the subject of the infinitive “to,” as well as the object of the sentence as a whole.</p>
</blockquote>
<blockquote>
<p>Many people thus propose that governments need to tackle this issue by controlling the media, whom they see as responsible for inciting this violence through films and television<br>(这里的whom是做宾语)</p>
</blockquote>
<blockquote>
<p>My father is a doctor whom people trusted.</p>
</blockquote>
<blockquote>
<p>Who/Whom are you going to invite to your party?<br>(这里you是主语)<br>你要邀请谁参加你的聚会？</p>
</blockquote>
<blockquote>
<p>Who/Whom can we turn to in case of an emergence?</p>
</blockquote>
<p>万一出现什么情况，我们可以求助于谁？</p>
<blockquote>
<p>We have no idea who/whom the president will choose to be the new manager.</p>
</blockquote>
<ul>
<li><p>无论是引导限制性定语从句还是非限制性定语从句，当先行词指人的时候，如果不是直接用于介词后作宾语，都可以用 who（非正式）或 whom（较正式）：</p>
</li>
<li><p>This aspect is discussed further by Crane, who / whom I mentioned earlier. 我前面提到过的克雷恩对这方面作了进一步的论述。</p>
</li>
<li><p>In that year he met Rachel, who / whom he was later to marry. 那年他遇到了雷切尔，后来和她结了婚。</p>
</li>
</ul>
<p>注意：直接用于介词后作宾语，只能用 whom：</p>
<ul>
<li>I met a man with whom I used to work.  我碰见了个过去曾一起工作的人。</li>
</ul>
<p>顺便说一句，引导特殊疑问句时也是如此。如：</p>
<p>Whom / Who are you writing to? 你在给谁写信?</p>
<p>Whom / Who do you like best? 你最喜欢谁?</p>
<p>若是紧跟在介词之后用作宾语，则只能用 whom，但这类表达通常只见于较正式的文体中。如：</p>
<p>With whom did you go? 你跟谁一起去的?</p>
<p><img src="/images/whom.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>p18-function-like-class</title>
    <url>/2022/06/16/function-like-class/</url>
    <content><![CDATA[<ul>
<li><a href="#%E4%B8%B4%E6%97%B6%E5%87%BD%E6%95%B0">临时函数</a><h1 id="临时函数"><a href="#临时函数" class="headerlink" title="临时函数"></a>临时函数</h1></li>
</ul>
<pre><code>#include&lt;iostream&gt;

class temporary&#123;
public:
    temporary()&#123;
            std::cout &lt;&lt; &quot;temporary ctor&quot; &lt;&lt;std::endl;
    &#125;
    ~temporary()&#123;
        std::cout &lt;&lt; &quot;destory&quot;  &lt;&lt;std::endl;
    &#125;
    void fun()&#123;
        std::cout &lt;&lt; &quot;This is function output&quot;  &lt;&lt;std::endl;
    &#125;

&#125;;
int main()&#123;
    
    temporary ().fun();
    return 0;
&#125;
</code></pre>
<p><strong>output</strong>:</p>
<pre><code>temporary ctor
This is function output
destory
</code></pre>
<ul>
<li>建立一个没有命名的非堆（non-heap）对象，也就是无名对象时，会产生临时对象</li>
</ul>
<pre><code>Integer inte= Integer(5); //用无名临时对象初始化一个对象
</code></pre>
<ul>
<li>构造函数作为隐式类型转换函数时，会创建临时对象，用作实参传递给函数。</li>
</ul>
<pre><code>class Integer
&#123;
public:
    Integer(int i):m_val(i)&#123;&#125;
    ~Integer()&#123;&#125;
private:
    int m_val;
&#125;;
 
void testFunc(Integer itgr)
&#123;
    //do something
&#125;

int  i = 10;
testFunc(i);

会产生一个临时对象，作为实参传递到 testFunc 函数中。
</code></pre>
<ul>
<li>函数返回一个对象时，会产生临时对象。以返回的对象作为拷贝构造函数的实参构造一个临时对象。</li>
</ul>
<pre><code>Integer Func()
&#123;
    Integer itgr;
    return itgr;
&#125;
 
int main()
&#123;
    Integer in;
    in = Func();
&#125;
</code></pre>
<h1 id="Why-we-need-function-like-class"><a href="#Why-we-need-function-like-class" class="headerlink" title="Why we need function-like class?"></a>Why we need function-like class?</h1><ul>
<li>让类实例化之后的对象可以作为一个参数进行传递（可以随时修改这个类，但是不影响其他类或者函数）</li>
</ul>
<p><img src="/images/function-like-class.png"></p>
<ul>
<li>标准库中存在很多仿函数，并且会继承很多奇特的base classes</li>
</ul>
]]></content>
      <tags>
        <tag>-c++</tag>
      </tags>
  </entry>
  <entry>
    <title>p19-namespace</title>
    <url>/2022/06/16/namespace/</url>
    <content><![CDATA[<h1 id="不同开发团队取的类名冲突"><a href="#不同开发团队取的类名冲突" class="headerlink" title="不同开发团队取的类名冲突"></a>不同开发团队取的类名冲突</h1><p><img src="/images/namespace.png"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>p22Member-Template</title>
    <url>/2022/06/17/p22Member-Template/</url>
    <content><![CDATA[<h2 id="模版内还有模版，一般用于构造函数中，"><a href="#模版内还有模版，一般用于构造函数中，" class="headerlink" title="模版内还有模版，一般用于构造函数中，"></a>模版内还有模版，一般用于构造函数中，</h2><ul>
<li>把草鱼和麻雀用于对鱼类和鸟类的初始化（作为构造函数传入）</li>
<li>这里的T1 first 能成功，是因为first是草鱼，是继承了鱼这个类的,也叫up-cast</li>
</ul>
<pre><code>// for smart pointer
template&lt;class _Tp&gt;
class shared_pte:public _shared_ptr&lt;_Tp&gt;&#123;

    ...
    template&lt;class _Tp1&gt;
    explicit shared_ptr(const _Tp1* _p):_shared_ptr&lt;_Tp&gt;(_p)&#123;&#125;
&#125;
shared_ptr&lt;Base1&gt;sptr(new Derived1);
</code></pre>
<ul>
<li>为了让构造函数更有弹性<br><img src="/images/member-template.png"></li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>review-paper</title>
    <url>/2022/06/17/review-paper/</url>
    <content><![CDATA[<p>Reviews:</p>
<ul>
<li><a href="#MUMLP">MUMLP</a></li>
<li><a href="#CUGCN">CUGCN</a></li>
</ul>
<p>===============================================</p>
<pre><code> It records all my papers reviews and certainly can thereby help me to improve my next 
 academic writing according those negative comments
</code></pre>
<h2 id="MUMLP"><a href="#MUMLP" class="headerlink" title="MUMLP"></a>MUMLP</h2><blockquote>
<p>Comments to the Author<br>This paper proposes a Multi-Scale U-shape Multi-Layer Perceptron (MUMLP) model. This method includes the designed MSC (Multi-Scale Channel) block and the UMLP (U-shape Multi-Layer Perceptron) structure. Some experiments are conducted to analyze the effectiveness of the proposed method. The main comments are</p>
</blockquote>
<p><strong>Reviewer: 1</strong></p>
<ol>
<li>   For the background, it lacks some key literatures about the hyperspectral image, which can refer to 10.1109/TGRS.2016.2583219 and 10.1109/LGRS.2019.2936652.</li>
<li>   Please rewrite the contributions to highlight the innovation. </li>
<li>   Table I and II can be combined to show the classification results of each class. </li>
<li>   For the experimental results, please enhance analysis the reason why the proposed method can achieve better results.</li>
<li>   Please demonstrate the effectiveness of each module in the proposed architecture. </li>
</ol>
<p><strong>Reviewer: 2</strong></p>
<ol>
<li>Since all the experiments are about image classification, and classification has different meaning compared with identification, change your title.</li>
<li>Main contribution of a paper should focus on the highlighted novelty, not the experimental results in numbers, refine the first two contributions and delete the last one.</li>
<li>Move Fig.2 and Table 1 into next pages.</li>
<li>Acknowledgement part is missing, at least acknowledge the data provider.</li>
</ol>
<hr>
<h2 id="CUGCN"><a href="#CUGCN" class="headerlink" title="CUGCN"></a>CUGCN</h2><blockquote>
<p>Associate Editor<br>Comments to the Author:<br>The expert reviewers have raised some major issues, particularly regarding the experimental section. Additionally, they asked for more clarification on the novelty of the proposed method compared with the state-of-the-art. I have some concerns myself that I mentioned below. I encourage the authors to apply the major changes and provide a point-by-point response letter addressing all the concerns.</p>
</blockquote>
<p><strong>Editor</strong></p>
<ol>
<li>The datasets used are all old. Please evaluate your method using newer benchmark datasets such as Houston 2013 and 2018.</li>
<li>Please provide the classification maps for all datasets. To save up space the authors can only select a few methods which provide the highest accuracies for the visual comparisons of the final maps.  </li>
<li>Please provide the hyperparameter analysis. How sensitive is the proposed method to the selection of hyperparameters?</li>
<li>Please provide citations for the competing methods used in the experiments. Additionally, I recommend the authors provide a comparison with an advanced shallow feature extraction technique such as OTVCA (see “Feature Extraction for Hyperspectral Imagery: The Evolution From Shallow to Deep: Overview and Toolbox”).</li>
<li>Please provide more detail regarding the selection of training samples.</li>
<li>Please provide the processing time and compare it to the competing methods.</li>
</ol>
<p><strong>reviewer 1</strong></p>
<blockquote>
<p>This paper presents a new model, named the Context-Aware Attentional Graph U-Net (CAGU), to improve interclass variabilities and interclass similarities when classifying hyperspectral data. In general, the paper is interesting since it provides some technical novelties within the remote sensing field. However, there are still some points about the work that should be improved before publication.</p>
</blockquote>
<ol>
<li><p>(Page 1, Line 25, Right) Please, define the acronyms before their first usage.</p>
</li>
<li><p>(Page 2, Line 57, Left) The authors should better motivate the use of a U-Net model with respect to other classification architectures.</p>
</li>
<li><p>(Page 2, Line 26, Right) Please, try to be more specific when detailing the contributions of the work. For instance, it is not a good idea describing Fig.1 or talking about the conducted experiments as contributions.</p>
</li>
<li><p>(Page 3, Line 37, Right) Please, try to join the paragraphs of this section when they are very short.</p>
</li>
<li><p>(Page 3, Line 53, Right) Do the authors think that it would be possible to consider alternative kernel sizes? Please, provide more information about this.</p>
</li>
<li><p>(Page 4, Line 20, Right) Please, try to better clarify the GRU model here. I think the writing is a little obfuscated. It would be also good to include some visual data here.</p>
</li>
<li><p>(Page 5, Line 25, Left) The considered sampling strategy is not clear. What is the rationale behind it?</p>
</li>
<li><p>(Page 5, Line 44, Left) Please, provide the references of the considered competitors.</p>
</li>
<li><p>(Page 5, Line 52, Right) Please, explain here the insights why the proposed approach is outperforming the other competitors.</p>
</li>
<li><p>Please, revise the whole writing carefully:<br>(Page 3, Line 54, Right) “Copy and crop operation combines”<br>(Page 4, Line 30, Left) “an Tesla”</p>
</li>
</ol>
<p><strong>Reviewer 2:</strong></p>
<p>Comments to the Author</p>
<blockquote>
<p>According to the submitted manuscript, my concerns are as follows.</p>
</blockquote>
<ol>
<li>The full classification maps are expected to be given.</li>
<li>Why is there only a classification map of Salinas dataset? If possible, please give the classification maps of other datasets.</li>
<li>In Salinas dataset, why is the 2nd order CAGU higher than the 1st one with 10% of the sampled data? There is no such situation in the Pavia data set and the Indian pines data set?</li>
<li>Please give the accuracy and loss function curves of the training and validation sets of the Pavia data set and the Indian pines data set.</li>
<li>In the experiment, the latest hyperspectral image algorithm based on graph convolutional network should be added to show the superiority of this algorithm.</li>
</ol>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>p23specialization</title>
    <url>/2022/06/17/specialization/</url>
    <content><![CDATA[<h1 id="Full-specialization"><a href="#Full-specialization" class="headerlink" title="Full specialization"></a>Full specialization</h1><pre><code>template &lt;class key&gt;
class hash&#123;&#125;

template&lt;&gt;
class hash&lt;char&gt;&#123;&#125;

template&lt;&gt;
class hash&lt;int&gt;&#123;&#125;

template&lt;&gt;
class hash&lt;long&gt;&#123;
    size_t operator() (const long x)&#123;
        return x;
    &#125;
&#125;

cout&lt;&lt; hash&lt;long&gt;() (100);
//先创建一个临时对象，之后调用（）重载

</code></pre>
<blockquote>
<p>full specialization aims to specialize some type.<br>for exampl:<br><strong>this is a function for judging equality of two members</strong></p>
</blockquote>
<pre><code>template&lt;class T&gt;
bool Isequal(T&amp; p1, T&amp; p2)&#123;
    return p1 == p2;
&#125;
</code></pre>
<p><strong>But it does’t work for string. We need to override this special type</strong></p>
<pre><code>
template&lt;&gt;
bool Isequal&lt;char*&gt; (char* p1, char* p2)&#123;    
    return strcmp(p1, p2) == 0;
&#125;
</code></pre>
<ul>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</li>
</ul>
<p>注意如果是函数模版，就不需要写&lt;&gt;</p>
<pre><code>template &lt;class T&gt;
T max(const T lhs, const T rhs)&#123;   
    return lhs &gt; rhs ? lhs : rhs;
&#125;

template &lt;&gt;
int max(const int lhs, const int rhs)&#123;   
    return lhs &gt; rhs ? lhs : rhs;
&#125;
//这是因为编译器根据int max(const int, const int)的函数签名可以推导出来它是T max(const T, const T)的特化。
</code></pre>
<blockquote>
<p>Note that if specialization funtion does’t have arugements. It has various interpretation. For example</p>
</blockquote>
<pre><code>template &lt;class T&gt;
void f()&#123; T d; &#125;

template &lt;&gt;
void f()&#123; int d; &#125;

此时编译器不知道f()是从f&lt;T&gt;()特化来的，编译时会有错误：

error: no function template matches function template specialization &#39;f&#39;
这时我们便需要显式指定&quot;模板实参&quot;：

template &lt;class T&gt;
void f()&#123; T d; &#125;

template &lt;&gt;
void f&lt;int&gt;()&#123; int d; &#125;
</code></pre>
<hr>
<h2 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization (偏特化)"></a>partial specialization (偏特化)</h2><ul>
<li>arguments (参数的个数上)</li>
<li>range: shrink the range. For example, arbitary type to pointer (任意类型的变为任意指针类型)</li>
</ul>
<p>For arguments:</p>
<blockquote>
<p>类似于全特化，偏特化也是为了给自定义一个参数集合的模板，但偏特化后的模板需要进一步的实例化才能形成确定的签名。 值得注意的是函数模板不允许偏特化，</p>
</blockquote>
<pre><code>template &lt;class T1, class T2&gt;
class A&lt;T1, T2&gt;&#123;
    ...
&#125;;
template &lt;class T2&gt;
class A&lt;int, T2&gt;&#123;
    ...
&#125;;


函数模板是不允许偏特化的，下面的声明会编译错：

template &lt;class T1, class T2&gt;
void f()&#123;&#125;

template &lt;class T2&gt;
void f&lt;int, T2&gt;()&#123;&#125;


但函数允许重载，声明另一个函数模板即可替代偏特化的需要：

template &lt;class T2&gt;
void f()&#123;&#125;              // 注意：这里没有&quot;模板实参&quot;

多数情况下函数模板重载就可以完成函数偏特化的需要，一个例外便是std命名空间。 std是一个特殊的命名空间，用户可以特化其中的模板，但不允许添加模板（其实任何内容都是禁止添加的）
</code></pre>
<p><strong>For range:</strong></p>
<pre><code>template &lt;class T&gt;
class A&#123;&#125;
template &lt;class U&gt;
class A&lt;U*&gt;&#123;&#125;
// we limit if the type is pointer thereby goes second class

A&lt;string&gt; a;

A&lt;string*&gt; b;
</code></pre>
<p>这个设计是为了如果针对指针要做不同的处理，就使用这个偏特化</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>template-template-paramenter</title>
    <url>/2022/06/17/template-template-paramenter/</url>
    <content><![CDATA[<h1 id="模版参数中包含模版"><a href="#模版参数中包含模版" class="headerlink" title="模版参数中包含模版"></a>模版参数中包含模版</h1><ul>
<li>允许模板参数本身也是一个类模板，这可能会很有用。我们将继续以stack类模板作为例子</li>
</ul>
<pre><code>template &lt;class T1, template&lt;class T2&gt; 
class Container&gt;

class XCls&#123;

    private:
    Container&lt;T&gt; c;
    public:
    ...
&#125;
template&lt;class T&gt;
using Lst = List&lt;T,allocator&lt;T&gt;&gt;;


XCls&lt;string, Lst&gt; mylst;
</code></pre>
<blockquote>
<p>由于Stack类模板的声明中第二个参数是一个类型（typename Container），所以我们通过Stack&lt;int, std::deque<int>&gt;定义一个具体的栈类型时，第二个参数传递std::deque<int>，而不能是std::deque。上述定义中我们一共把int写了两遍，而这种重复是一种必然的重复。</p>
</blockquote>
<p>为了避免上述重复，我们可以让Stack的第二个参数直接是一个模板，而不再是一个具体类型。</p>
<pre><code>template&lt;typename T,
         template&lt;typename&gt; class Container = std::vector&gt;
struct Stack
&#123;
    void push(const T&amp; elem)
    &#123;
        elems.push_back(elem);
    &#125;

    T pop()
    &#123;
        if(empty()) throw std::out_of_range(&quot;Stack&lt;&gt;::pop: empty!&quot;);

        auto elem = elems.back();
        elems.pop_back();
        return elem;
    &#125;

    bool empty() const
    &#123;
        return elems.empty();
    &#125;

private:
    Container&lt;T&gt; elems;
&#125;;
</code></pre>
<blockquote>
<p>如上Stack类模板的第二个参数变为template<typename> class Container，它的名字仍旧是Container，但是类型变为一个模板，这个模板具有一个类型参数。由于Container自身的模板形参名字没有被使用，所以我们可以省略。按照标准这里声明Container前的关键字只能是class，不能是typename。最后，模板的模板参数也可以有默认值，这里我们设置为std::vector。</p>
</blockquote>
<p>有了上面的定义，我们期望可以这样使用Stack：Stack&lt;int, std::deque&gt; intStack，但编译器却给了我们一个教训。</p>
<p>std::deque类模板在stl库中的定义有两个类型参数，第一个参数是元素类型，第二个参数是分配器allocator的类型。虽然std::deque的第二个类型参数有默认值，但是当编译器使用std::deque替换Container时却会严格匹配参数，默认值被忽略了。</p>
<p>我们修改Stack的定义如下：</p>
<pre><code>template&lt;typename T,
         template&lt;typename Elem, typename Allocator = std::allocator&lt;Elem&gt;&gt; class Container = std::vector&gt;
struct Stack
&#123;
    void push(const T&amp; elem)
    &#123;
        elems.push_back(elem);
    &#125;

    T pop()
    &#123;
        if(empty()) throw std::out_of_range(&quot;Stack&lt;&gt;::pop: empty!&quot;);

        auto elem = elems.back();
        elems.pop_back();
        return elem;
    &#125;

    bool empty() const
    &#123;
        return elems.empty();
    &#125;

private:
    Container&lt;T&gt; elems;
&#125;;
</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Conv-MPN</title>
    <url>/2022/06/17/Conv-MPN/</url>
    <content><![CDATA[<h2 id="This-is-my-notes-for-paper-“Conv-MPN-Convolutional-Message-Passing-Neural-Network-for-Structured-Outdoor-Architecture-Reconstruction-”"><a href="#This-is-my-notes-for-paper-“Conv-MPN-Convolutional-Message-Passing-Neural-Network-for-Structured-Outdoor-Architecture-Reconstruction-”" class="headerlink" title="This is my notes for paper “Conv-MPN: Convolutional Message Passing Neural Network for Structured Outdoor Architecture Reconstruction.”"></a>This is my notes for paper <strong>“Conv-MPN: Convolutional Message Passing Neural Network for Structured Outdoor Architecture Reconstruction.”</strong></h2><ul>
<li><a href="#">corner_detection</a><blockquote>
<p>concatenate </p>
</blockquote>
</li>
</ul>
<h1 id="corner-detection"><a href="#corner-detection" class="headerlink" title="corner_detection"></a>corner_detection</h1><blockquote>
<p>mask_rcnn extracts corner points.</p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cout重载全局函数</title>
    <url>/2022/06/17/cout%E9%87%8D%E8%BD%BD%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="为什么c-中重载流操作符要用友元函数"><a href="#为什么c-中重载流操作符要用友元函数" class="headerlink" title="为什么c++中重载流操作符要用友元函数"></a>为什么c++中重载流操作符要用友元函数</h1><h2 id="作为成员函数的话，左操作数非得是自己不可"><a href="#作为成员函数的话，左操作数非得是自己不可" class="headerlink" title="作为成员函数的话，左操作数非得是自己不可"></a>作为成员函数的话，左操作数非得是自己不可</h2><blockquote>
<p>cout &lt;&lt; XXX 这种情况是cout在调用operator&lt;&lt;而不是XXX在调用operator&lt;&lt; 。<br>如果你要把operator&lt;&lt;设为成员函数就只能用 XXX &lt;&lt; cout 这种形式。</p>
</blockquote>
<p><strong>所以这样也是可以的，就是有违常理</strong></p>
<pre><code>struct point
&#123;
    int x;
    int y;

    point (int _x, int _y)
        : x(_x), y(_y)
    &#123;&#125;

    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os) const
    &#123;
        os &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot;;
        return os;
    &#125;
&#125;;

int main(int argc, const char* argv[])
&#123;
    point p1(1, 2);

    p1 &lt;&lt; std::cout; // 写法同p1.operator&lt;&lt;(std::cout);

    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>模版内的友元</title>
    <url>/2022/06/18/%E6%A8%A1%E7%89%88%E5%86%85%E7%9A%84%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<h1 id="模板类使用友元模板函数"><a href="#模板类使用友元模板函数" class="headerlink" title="模板类使用友元模板函数"></a>模板类使用友元模板函数</h1><p>在类模板中可以出现三种友元声明：<br>（1）普通非模板类或函数的友元声明，将友元关系授予明确指定的类或函数。<br>（2）类模板或函数模板的友元声明，授予对友元所有实例的访问权。<br>（3）只授予对类模板或函数模板的特定实例的访问权的友元声明。</p>
<p>（1）普通友元：</p>
<pre><code>template&lt;class T&gt;

class A&#123;

   friend void fun();

//...

&#125;;
此例中fun可访问A任意类实例中的私有和保护成员
</code></pre>
<p>（2）一般模板友元关系</p>
<pre><code>template&lt;class type&gt;

class A&#123;

  template&lt;classT&gt;

   friend void fun(T u);

//...

&#125;;

这时友元使用与类不同的模板形参，T可以是任意合法标志符，友元函数可以访问A类的任何类实例的数据，即不论A的形参是int，double或其他都可以。
</code></pre>
<p>（3）特定的模板友元关系</p>
<pre><code>template &lt;class T&gt; void fun(T,u);//对与特定的模板友元关系，这里的声明是必须的

template&lt;class T&gt;

class A&#123;

   friend voidfun&lt;T&gt;(T u);//这里也可以是friend void fun&lt;char&gt;(char u);

//...

&#125;;

此时fun只有访问类中特定实例的数据。换句话说，此时具有相同模板实参的fun函数与A类才是友元关系。即假如调用fun时其模板实参为int，则它只具有A&lt;int&gt;的访问权限。当然friendvoid fun&lt;T&gt;(Tu);中&lt;&gt;中的T可以是任意类型，比如int，double等

 

 

 

对类建立友元函数很容易。但是迁移到模板上却容易出现让人摸不着头脑的连接错误。
层次不够，不做分析，单纯介绍两种为类模板定义友元函数的方法
</code></pre>
<pre><code>　　１　封闭型

template&lt; typename T &gt;
class MyClass
&#123;
    friend void function( MyClass&lt; T &gt; &amp;arg )
    &#123;
        
     &#125;
 &#125;;　　要点：友元函数定义在模板体内。

       ２　开放型
template&lt; typename T &gt;
class MyClass
&#123;
    template&lt; typename C &gt;
    friend void function( MyClass&lt; C &gt; &amp;arg );
 &#125;;

template&lt; typename C &gt;
void function( MyClass&lt; C &gt; &amp;arg )
&#123;
    
 &#125;　　要点：模板体内要另建模板。 
　　
　　3 告诉编译器声明的设个是模板
#include &lt;iostream&gt;
using namespace std;

template &lt; typename T &gt;
class A
&#123;
    friend ostream &amp;operator&lt;&lt; &lt; T &gt;( ostream &amp;, const A&lt; T &gt; &amp; );
 &#125;;

template &lt; typename T &gt;
ostream &amp;operator&lt;&lt; ( ostream &amp;output, const A&lt; T &gt; &amp;a )
&#123;
    output &lt;&lt; &quot;重载成功&quot; &lt;&lt; endl;
    return output;
 &#125;

int main()
&#123;
    A&lt; int &gt; a;
    cout &lt;&lt; a;
 &#125;要点：显示地在重载的运算符或者函数后面加上模板声明&lt; T&gt;，告诉编译器友元函数是一个类型一致的模板。
</code></pre>
<p> 建议：<br>            如果希望使用函数与模板特化的类型相对应，则使用方法3（模板显示声明）<br>            如果希望使用函数与模板特化的类型相独立，则使用方法2（二重模板）<br>            简短的内联函数使用方法1</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>p33const</title>
    <url>/2022/06/19/p33const/</url>
    <content><![CDATA[<h1 id="const-规则"><a href="#const-规则" class="headerlink" title="const 规则"></a>const 规则</h1><p><img src="/images/const.png"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>p27variadic-template</title>
    <url>/2022/06/18/p27variadic-template/</url>
    <content><![CDATA[<h1 id="不定模版参数"><a href="#不定模版参数" class="headerlink" title="不定模版参数"></a>不定模版参数</h1><pre><code>template &lt;class T1, class... args&gt;
void test(T1 t, args&amp;... arg)&#123;

&#125;
test(1,2,&#39;a&#39;,&#39;c&#39;); 
</code></pre>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><pre><code>list&lt;string&gt; c;
auto ite = find(c.begin(), c.end(),traget);
//auto声明变量的时候必须就赋值
auto ite; //这行和下一行是不对的
itr = find(c.begin(), c.end(),traget);

or
list&lt;string&gt;::interate ite = find(c.begin(), c.end(),traget);
</code></pre>
<h1 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h1><pre><code>for (decl:coll)&#123;
    statement
&#125;
for(auto elem:vec)&#123; //这每个拿出来赋值到左边
    // 右边是容器，左边是输出的每个数
    cout &lt;&lt; elem &lt;&lt; endl;
&#125;
//用引用也行
for(auto&amp; elem:vec)&#123;
    // 右边是容器，左边是输出的每个数
    cout &lt;&lt; elem &lt;&lt; endl;
&#125;

for (int i:&#123;1,2,3,4,5&#125;)&#123;
    cout &lt;&lt; i;
&#125;
</code></pre>
<h1 id="传引用和传value是相同的signature"><a href="#传引用和传value是相同的signature" class="headerlink" title="传引用和传value是相同的signature"></a>传引用和传value是相同的signature</h1><p>signature指的是除了返回值类型的余下部分<br>double image(const double&amp; in) const {}<br>double image(const double in) const {}</p>
<blockquote>
<p>上面两个是相同的，不能同时存在</p>
</blockquote>
<p> notes：image() 后的const也是signature的一部分，<br> double image(const double&amp; in) const {}<br>double image(const double in) {}</p>
<blockquote>
<p>这样是可以共存的</p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>other和others</title>
    <url>/2022/06/21/other%E5%92%8Cothers/</url>
    <content><![CDATA[<h2 id="other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others-other-复数名词。others通常为代词"><a href="#other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others-other-复数名词。others通常为代词" class="headerlink" title="other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others=other+复数名词。others通常为代词"></a>other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others=other+复数名词。others通常为代词</h2><blockquote>
<p>He never thinks of <code>others</code>. 他从来不为别人着想。</p>
</blockquote>
<blockquote>
<p>I don’t like these books. Show me some others. 我不喜欢这些书，再拿一些给我看。</p>
</blockquote>
<p>第一句中的others=other people，意为“其他人”“别人”，泛指其他所有人；第二句中的others=other books，意为“其他的书”。</p>
<p>但是，若要表示确指意义，我们就在other和others前面使用定冠词，同样地，other后可以修饰名词，而others后不能再接名词，两者的关系仍然存在the others=the other+复数名词。如：</p>
<blockquote>
<p>I started last in the race but I soon caught up with the others. 我在赛跑中最后一个起跑，但不久就赶上了其他人。</p>
</blockquote>
<p>句中的the others=the other people，意为“其他人”，其中的定冠词特指参加赛跑的所有其他人。</p>
<blockquote>
<p>注意：the other后除接复数名词外，还可以接单数名词，此时不能用the others代替。如：</p>
</blockquote>
<p>This seat is free; the other seat is taken. 这个座位空着，那个座位有人。</p>
<h2 id="常用惯用表达"><a href="#常用惯用表达" class="headerlink" title="常用惯用表达"></a>常用惯用表达</h2><p>①<code>one...the other</code>表示“(两者中的)一个……另一个……”。如：</p>
<p>What I say goes in at one ear and out at the other. 我说话他是一只耳朵进，另一只耳朵出。</p>
<p>②<code>one...the others</code>表示“(好几个中的)一个……其余都……”。如：</p>
<p>Of their five children, one is in China and the others are abroad. 他们有五个小孩，一个在中国，其余的都在国外。</p>
<p>注：若为三者，想要表示“一个……另一个……剩下的一个……”，可用one…another…the other [the third…]；若为四者，可用one…another…another [a third]…the other [the fourth, the last]。</p>
<p>③<code>some...the others</code>表示“一些……其他一些的……”。如：</p>
<p>The search party was divided into two groups. Some went to the right, the others went to the left. 搜寻小组一分为二，一部分向右，另一部分人向左。</p>
<p>④<code>some…others</code>表示“有的……有的……”。如：</p>
<p>Some people build while others destroy. 有些人建设而另一些人则破坏。</p>
<p>注：该结构也可说成some…some。如：</p>
<p>Some of us agree, some disagree. 我们有些人同意，有些人不同意。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>重载new()</title>
    <url>/2022/06/21/%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="可以重载new，同时也可以重载new"><a href="#可以重载new，同时也可以重载new" class="headerlink" title="可以重载new，同时也可以重载new()"></a>可以重载new，同时也可以重载new()</h2><p>Foo* p = new(300,”a”) Foo;</p>
<blockquote>
<p>new()里面的参数就是可以加在重载函数的参数中的<br>注意第一个参数必须是size_t</p>
</blockquote>
<pre><code>void* operator new(size_t size, int a, char c)&#123;
.....
&#125;
</code></pre>
<blockquote>
<p>这样就可以写错多个版本的new重载</p>
</blockquote>
<h2 id="delete-也可以这样写多个版本，对应new-参数版本。"><a href="#delete-也可以这样写多个版本，对应new-参数版本。" class="headerlink" title="delete()也可以这样写多个版本，对应new()参数版本。"></a>delete()也可以这样写多个版本，对应new()参数版本。</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>FLOPs</title>
    <url>/2022/06/26/FLOPs/</url>
    <content><![CDATA[<p><img src="/images/FLOPs.png"></p>
]]></content>
      <tags>
        <tag>FLOPs</tag>
      </tags>
  </entry>
  <entry>
    <title>probability</title>
    <url>/2022/06/22/probability/</url>
    <content><![CDATA[<h2 id="68-95-99"><a href="#68-95-99" class="headerlink" title="68-95-99"></a>68-95-99</h2><ul>
<li>During one standard, it has 68% probability in it.</li>
<li>During tow standards, it has 95% probability in it.</li>
<li>During three standards, it has 99% probability in it.</li>
</ul>
]]></content>
      <tags>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title>t5-假设检验</title>
    <url>/2022/06/22/t5%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<p><img src="/images/p5.png"></p>
]]></content>
      <tags>
        <tag>probability</tag>
      </tags>
  </entry>
</search>
