<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3D</title>
    <url>/2021/11/05/3D/</url>
    <content><![CDATA[<!-- Do you need some help for 3D?
I skipped some lectures, so first of all I need to rewatch that. After that, I will ask some help, thanks 
aassigments
I will try figure out by myself, then i will ask sometjiogn  -->
<blockquote>
<p>trangulation<br>tip: e2（第二个图像的极点是第一个图片的focal（焦点）在第二个坐标系下的投影），e2 &#x3D; K’[R T][0,0,0,1]T([0,0,0,1]是第一个图片的坐标原点（世界坐标系的原点）)<br>问题一：为什么要进行相机标定？<br>相机标定的目的是：建立相机成像几何模型并矫正透镜畸变。这句话有点拗口，下面分别对其中两个关键部分进行解释。</p>
</blockquote>
<blockquote>
<p>建立相机成像几何模型：计算机视觉的首要任务就是要通过拍摄到的图像信息获取到物体在真实三维世界里相对应的信息，于是，建立物体从三维世界映射到相机成像平面这一过程中的几何模型就显得尤为重要，而这一过程最关键的部分就是要得到相机的内参和外参（后续文有具体解释）。</p>
</blockquote>
<blockquote>
<p>矫正透镜畸变：我们最开始接触到的成像方面的知识应该是有关小孔成像的，但是由于这种成像方式只有小孔部分能透过光线就会导致物体的成像亮度很低，于是聪明的人类发明了透镜。虽然亮度问题解决了，但是新的问题又来了：由于透镜的制造工艺，会使成像产生多种形式的畸变，于是为了去除畸变（使成像后的图像与真实世界的景象保持一致），人们计算并利用畸变系数来矫正这种像差。虽然理论上可以设计出不产生畸变的透镜，但其制造工艺相对于球面透镜会复杂很多，所以相对于复杂且高成本的制造工艺，人们更喜欢用数学来解决问题。</p>
</blockquote>
<p>相机成像模型<br>前面已经说过，相机标定的目的之一是为了建立物体从三维世界到成像平面上各坐标点的对应关系，所以首先我们需要定义这样几个坐标系来为整个过程做好铺垫：</p>
<blockquote>
<p>世界坐标系(world coordinate system)：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。</p>
</blockquote>
<blockquote>
<p>相机坐标系(camera coordinate system)：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像&#x2F;像素坐标系的中间一环。单位为m。</p>
</blockquote>
<blockquote>
<p>图像坐标系(image coordinate system)：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 单位为m。</p>
</blockquote>
<blockquote>
<p>像素坐标系(pixel coordinate system)：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。单位为个（像素数目）。</p>
</blockquote>
<p>一下子定义出来四个坐标系可能有点晕，下图可以更清晰地表达这四个坐标系之间的关系：<br><img src="/images/3D-1.jpeg"></p>
<h2 id="世界坐标系：Xw、Yw、Zw。相机坐标系：-Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。"><a href="#世界坐标系：Xw、Yw、Zw。相机坐标系：-Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。" class="headerlink" title="世界坐标系：Xw、Yw、Zw。相机坐标系： Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。"></a>世界坐标系：Xw、Yw、Zw。相机坐标系： Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。</h2><blockquote>
<p>其中，相机坐标系的z轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点，相机坐标系与图像坐标系之间的距离为焦距f（也即图像坐标系原点与焦点重合）。像素坐标系平面u-v和图像坐标系平面x-y重合，但像素坐标系原点位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。<br><img src="/images/3D-2.jpeg"><br>下面将依次对刚体进行一系列变换，使之从世界坐标系进行仿射变换、投影透射，最终得到像素坐标系下的离散图像点，过程中会逐步引入各参数矩阵。</p>
</blockquote>
]]></content>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>3D-python</title>
    <url>/2021/11/02/3D-python/</url>
    <content><![CDATA[<h1 id="plot-3D-by-python"><a href="#plot-3D-by-python" class="headerlink" title="plot 3D by python"></a>plot 3D by python</h1>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>BPR推荐算法</title>
    <url>/2021/11/16/BPR/</url>
    <content><![CDATA[<p><img src="/images/BPR.png"> </p>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>BRP推荐算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/2022/01/13/C/</url>
    <content><![CDATA[<blockquote>
<p>静态函数不能访问非静态变量<br>static method cannot access non-static variables<br>静态函数不会被实例化（不存在对象），就像是写在类外部的函数一样</p>
</blockquote>
<pre><code>static void Print(classname e)&#123;

    std::cout&lt;&lt;e.x &lt;&lt; std::endl;
&#125;
&#39;&#39;&#39;
&gt;临时变量作为非const的引用进行参数传递引发的编译错误_mlove编程-程序员宝宝
技术标签： QT  qt  string  linux  

1.错误原因即解决办法
Linux环境运行，使用g++编译，观察如下代码，会出现： invalid initialization of non-const reference of type ‘std::string&amp;’ from a temporary of type ‘std::string’的错误。

其中文意思为临时变量无法为非const的引用初始化。也就是在参数传递的过程中，出现错误。出错的代码如下
</code></pre>
<p>void print(string&amp; str)<br>{<br>    cout&lt;&lt;str&lt;&lt;endl;<br>}<br>&#x2F;&#x2F;如此调用会报上面描述的错误</p>
<pre><code>print(&quot;hello world&quot;);


出错的原因是编译器根据字符串”hello world”构造一个string类型的临时对象，这个临时对象具有const属性。当这个临时对象传递给非const的string&amp;引用类型时，因为非const引用绑定对象时，要求该对象也是非const对象。而在这时，因为string类型的临时对象是const对象，所以就出现错误。因此，解决办法就是将print()函数的参数改为常引用。代码修改如下，可顺利通过编译。

void print(const string&amp; str)
&#123;
    cout&lt;&lt;str&lt;&lt;endl;
&#125;
//顺利通过编译
print(&quot;hello world&quot;);
通过以上代码，也可以看出Effective C++中倡导的一个C++的编程原则，即尽可能的使用const。因为这样可以使代码更为健壮，将错误暴露于编译阶段。

2.所有的临时对象都是const对象吗
为什么临时对象作为引用参数传递时，必须是常量引用呢？很多人对此的解释是临时对象是常量，不允许赋值改动，所以作为非常量引用传递时，编译器就会报错。这个解释在关于理解临时对象不能作为非const引用参数这个问题上是可以的，但不够准确。更有甚者，认为所有的临时对象均是const对象，因此，对于网上的观点和资源我们应该持着谨慎怀疑的态度去接受学习，应该坚持鲁迅先生倡导的”拿来主义”，应该批判参考和借鉴。

事实上，临时变量是可以被作为左值(LValue) 并被赋值的，请看下面的代码：

class IntClass&#123;
private:
    int x;
public:
    IntClass(int value):x(value)&#123;
    &#125;

    friend  ostream&amp; operator&lt;&lt;( ostream &amp;os, const IntClass &amp;intc);
&#125;;

//重载输出operator&lt;&lt;
ostream&amp; operator&lt;&lt;( ostream &amp;os, const IntClass &amp;intc)
&#123;
    os&lt;&lt;intc.x;
    return os;
&#125;

//打印函数
void print(IntClass &amp; intc)
&#123;
    cout&lt;&lt;intc&lt;&lt;endl;
    //通过引用修改这个临时对象
    intc=8;
    cout&lt;&lt;intc&lt;&lt;endl;
&#125;

int main(int argc,char* argv[])
&#123;
    print(IntClass(6));
&#125;
程序输出：
6
8

以上代正确编译运行，没有错误。IntClass(6)表示生成一个无名的临时对象，传递给非const引用，在print函数中通过引用修改了这个临时对象。这说明了并非所有的临时对象都是const对象。

那哪些临时对象是const对象，哪些临时对象不是const对象呢？这里贴上摘自网上的一句话：“内置类型产生的临时变量具有常性，而自定义类型产生的临时变量不具有常性”，我想这句话能解释你所谓的临时变量为什么能作为左值的原因。

int* const a = new int;
这个不能修改指针a, 如 a = &amp;b; 报错
const int* a = new int; int const* a = new int; 这两个相同，看const的位置
这个不能修改指针a指向的内容， *a = 2; 报错 
</code></pre>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Context-Aware Attentional Graph U-Net for Hyperspectral Image Classification</title>
    <url>/2021/03/31/CAGU/</url>
    <content><![CDATA[<p><img src="/images/2_author.jpg"> </p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract :"></a>Abstract :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">Hyperspectral Image (HSI) registers hundreds of spectral bands, whose intraclass variability and interclass similarity are resourceful information to be mined. Intraclass variability reflects the non-uniform and redundancy of the spatial and semantic features extracted from HSI. Interclass similarity represents the inherent relationship between adjacent features and snapshots. Existing models extract the superficial correlation representation for HSI to tackle the classification task but fail to embed the interclass and intraclass correlations due to these models intrinsic bottlenecks. Confronting the challenges of capturing interrelation for complex data in practice, we propose a Context-Aware Attentional Graph U-Net (CAGU) to improve these two modes of representation, which is more flexible in feature enhancement. In this method, attentional Graph U-Net is capable of extracting the intraclass embeddings within a non-Euclidean space by combining similar distributing feature vertices. The Gated Recurrent Unit (GRU) is another critical component of our model to capture the context-aware dynamic interclass embeddings. Extensive experiments demonstrate that our model can efficiently outperform state-of-the-art methods across-the-board on five wide-adopted public datasets, namely Pavia University, Indian Pines, Salinas Scene-show, Houston 2013 and Houston 2018, on a par with the same scale of model parameters.
</blockquote>
<h1 id="CAGU-Architecture"><a href="#CAGU-Architecture" class="headerlink" title="CAGU Architecture :"></a>CAGU Architecture :</h1><p> <img src="/images/2_2.jpg"> </p>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results :"></a>Results :</h1><p> <img src="/images/2_3.jpg"> </p>
<h1 id="Classification-maps"><a href="#Classification-maps" class="headerlink" title="Classification maps :"></a>Classification maps :</h1><p> <img src="/images/2_5.jpg"> </p>
<h1 id="Innovation"><a href="#Innovation" class="headerlink" title="Innovation :"></a>Innovation :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph;color:black"> CAGU considers the intrinsic relationship in feature space, and promotes high cohesion of features through the graph network. CAGU can explore deeper spectral information in the image than the state-of-the-art methods, which enhances the cohesion of features and provides clear data for subsequent modules. Therefore, CAGU outperforms all the compared methods, and it can be universally employed in most models for feature enhancement, not restricted in U-Net. What’s more, GCN and GRU will not increase the parameters of the model due to the reduction in depth of U-Net.
</blockquote>
<hr>
<h1 id="Publish"><a href="#Publish" class="headerlink" title="Publish :"></a>Publish :</h1><h3 id="Journal-IEEE-Geoscience-and-Remote-Sensing-Letters"><a href="#Journal-IEEE-Geoscience-and-Remote-Sensing-Letters" class="headerlink" title="Journal : IEEE Geoscience and Remote Sensing Letters"></a>Journal : IEEE Geoscience and Remote Sensing Letters</h3><h3 id="Impact-factor-3-833"><a href="#Impact-factor-3-833" class="headerlink" title="Impact factor : 3.833"></a>Impact factor : 3.833</h3><h3 id="State-Accepted-28-Mar-2021"><a href="#State-Accepted-28-Mar-2021" class="headerlink" title="State : Accepted (28-Mar-2021)"></a>State : Accepted (28-Mar-2021)</h3><p><img src="/images/2_4.jpg"> </p>
<h1 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration :"></a>Declaration :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph;color:black;font-size:20px"> When the paper is published, we will open source the code.<br>
<p style="text-align:right;color:black;font-size:20px"> --&nbsp;Moule Lin </blockquote>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>CAGU</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplusnotes</title>
    <url>/2022/05/01/Cplusplusnotes/</url>
    <content><![CDATA[<blockquote>
<p>静态函数只能访问静态数据</p>
</blockquote>
<blockquote>
<p>为什么static成员变量一定要在类外初始化?</p>
</blockquote>
<pre><code>static变量属于类，非对象，如果在类内初始了，该类再一次创建对象将变成初始值，会修改其他对象对该静态变量操作的意图可能发生意外
但是
static const int a = 1;
这个可以在类内初始化，因为const说明这个变量是不变的，因此对于每个对象来说，static内存块的的数据就是一样的
</code></pre>
<h2 id="为什么静态成员不能在类内初始化？"><a href="#为什么静态成员不能在类内初始化？" class="headerlink" title="为什么静态成员不能在类内初始化？"></a>为什么静态成员不能在类内初始化？</h2><p>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。</p>
<p>class A<br>{<br>private:<br>static int count ; &#x2F;&#x2F; 类内声明<br>};</p>
<ul>
<li><p>类外定义并初始化，不必再加static关键字<br>int A::count &#x3D; 0 ;<br>或者只进行定义不赋初始值，但是默认值是否是0，可能会与具体的编译器有关吧？</p>
</li>
<li><p>只进行定义不赋初始值，但默认值视编译器而定<br>int A::count;<br>为什么？</p>
</li>
<li><p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p>
</li>
</ul>
<p>如果不增加int A::count &#x3D; 0 ; &#x2F;&#x2F;变量定义，在编译的时候将会报出：‘A::count’未定义的引用”错误。这是因为静态成员变量count未定义，也就是还没有分配内存，显然是不可以访问的。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DBSCAN</title>
    <url>/2022/01/06/DBSCAN/</url>
    <content><![CDATA[<p><img src="/images/DBSCAN.png"> </p>
]]></content>
      <tags>
        <tag>DBSCAN</tag>
      </tags>
  </entry>
  <entry>
    <title>Conv-MPN</title>
    <url>/2022/06/17/Conv-MPN/</url>
    <content><![CDATA[<h2 id="This-is-my-notes-for-paper-“Conv-MPN-Convolutional-Message-Passing-Neural-Network-for-Structured-Outdoor-Architecture-Reconstruction-”"><a href="#This-is-my-notes-for-paper-“Conv-MPN-Convolutional-Message-Passing-Neural-Network-for-Structured-Outdoor-Architecture-Reconstruction-”" class="headerlink" title="This is my notes for paper “Conv-MPN: Convolutional Message Passing Neural Network for Structured Outdoor Architecture Reconstruction.”"></a>This is my notes for paper <strong>“Conv-MPN: Convolutional Message Passing Neural Network for Structured Outdoor Architecture Reconstruction.”</strong></h2><ul>
<li><a href="#">corner_detection</a><blockquote>
<p>concatenate</p>
</blockquote>
</li>
</ul>
<h1 id="corner-detection"><a href="#corner-detection" class="headerlink" title="corner_detection"></a>corner_detection</h1><blockquote>
<p>mask_rcnn extracts corner points.</p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>DP</title>
    <url>/2022/03/18/DP/</url>
    <content><![CDATA[<p><img src="/images/DP.png">  </p>
]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>English-Sentences</title>
    <url>/2021/11/01/English-Sentences/</url>
    <content><![CDATA[<h1 id="Some-sentences-autumn-break"><a href="#Some-sentences-autumn-break" class="headerlink" title="Some sentences autumn break"></a>Some sentences autumn break</h1><pre><code>We&#39;ll take a look some
That is where English comes in
English is no exception
Have come up with 提出
Rushed
Discover
How can I ever repay you
Don’t beat around the bush
explaining
easier said than done
don&#39;t judge a book by its cover

It is fair to say ~~
Keep up to
But out of all the available methods
Density noun
Destined adj
Be slowed down
Over here
lies ahead
Would I be talking about something
Hopefully soon
take a close look 我们仔细看看
small talk  闲聊
Between people and involoved
There are many popular topics of conversation when it comes using small-talk
Isn&#39;t it a lovely weather
We are having these day
Forecast
Reasons being

throw the book at sb 狠狠责罚（某人） ；给……以最严厉的惩罚

If no one has anything else to add, let’s wrap up the meeting

定冠词后接形容词表示同一类人或物或抽象概念，作主语谓语复数

who和whom的区别和he和him的区别是一样：
who可以理解为主格，做主语；whom可以理解为宾格，做宾语。
To whomcan we turn in case of an emergence?
注意：介词后一定要用whom:
可用who代替whom：
Whocame to the party last night?
昨晚都谁来参加聚会了？
Who/Whomare you going to invite to your party?
You have great taste in furniture
I really like what you have done with this house
Stylish == fashionable

</code></pre>
<hr>
<blockquote>
<p>While perhaps not as popular as CSS selectors, XPath expressions offer more power because besides navigating the structure, it can also look at the content.</p>
</blockquote>
<pre><code>While perhaps not as popular as CSS selectors, XPath expressions offer more power because besides navigating the structure, it can also look at the content.

The best way to learn is with examples, and Scrapy is no exception.

had better
1. 意思是“应该；最好”;
You had better study hard for your entrance exam.
You had better see the doctor about your cough.
2. 后接不带 to 的不定式：had better do sth;
you had better be careful.
It’s five o’clock. I’d better go now before the traffic gets too bad.
3.其用法相当于情态动词，动词 had 没有人称或数的变化。
She’d better get here soon or she’ll miss the opening ceremony.
4.常用来提出建议，语气较强，我们一般强调如果不这样做会有不好的后果。
或表示迫切的希望，警告等。
We&#39;d better take something to eat or we will be hungry later.
You had better lock the door before you leave.
You had better unplug the toaster before you try to clean it.
</code></pre>
<h1 id="被动"><a href="#被动" class="headerlink" title="被动"></a>被动</h1><blockquote>
<p>主动态表示句子的主语是行为的发生者或执行者。被动态表示句子的主语是行为的承受者。如果需要体现动作的发生者，需要借助by，谓语的时态要用“be的相应时态+过去分词”的来表。<br>看不懂没关系，给个例子就懂了。<br>[举例]过去时态下的被动语态<br>主动态：The teacher gave me the book.<br>被动态：I was given the book by the teacher.<br>从这个例子中可以看出，老师给我一本书，老师是动作的发生者，我是动作的承受者。所以在主动态中，主谓宾依次排放。<br>但当在被动态中。宾语放在了名首，所以宾语要承担动作。谓语就要发生相应的变化。由原来的gave改变为was given（记忆法：被动态中，一般现在时is&#x2F;are + done，过去时was&#x2F;were + done，将来时 shall&#x2F;will be + done）。<br>[举例]现在完成时态下的被动语态<br>主动态：We have finished our work.<br>被动态：Our work has been finished.<br>（记忆法：被动态中，现在完成时has&#x2F;have been + done，过去完成时had been + done，将来完成时 shall&#x2F;will have been + done）。<br>学到这里，不知大家有没有注意到，have been done 又出现了。与今天主题句They have been married for more than 10 years.中have been married的句型完全一样。所以主题句使用的是被动句？<br>答案是：否，这也是大家在学习被动句后，特别要注意的一点。<br>●“be + 过去分词”不一定就是被动态<br>[例句]<br>The glass plate is broken. 这玻璃板是破的。（作表语）<br>The glass plate was broken by him. 这玻璃板（当时）被他打碎了。（被动态）<br>[例句]<br>The book is written well. 这本书写得很好。（作表语）<br>The book has been written by our teacher. 这本书已经由我们的老师写成。（被动态）<br>拿今天的主题句来进行解析。<br>They have been married for more than 10 years.<br>简短点来说“他们结婚了”<br>They are married.<br>“他们已经结婚了”<br>They have been married.<br>所以今日主题句的句型属于表语形式，并不是被动态哦。</p>
</blockquote>
<h1 id="words"><a href="#words" class="headerlink" title="words"></a>words</h1><blockquote>
<p>examine<br>scar scary scarf (scare v)<br>apparnently, the two things that people are most afraid of<br>when it comes to making a speech<br>used to do和be used to doing的含义不同，be used to doing表达习惯于做某事的意思；used to所表示的意思是“过去常常做某事”，强调过去发生的事，所以一般用于描述发生在过去的事情。<br>Get used to ：开始习惯于（从不习惯到习惯的一个过程）</p>
</blockquote>
<p>用法：Get used to V-ing&#x2F;sth</p>
<p>这里的to也是充当介词，因此后面要有动名词或者名词</p>
<p>The food here is not so tasty but you will get used to that.</p>
<p>这里的伙食不怎么样，但你会慢慢习惯的。</p>
<p>Be used to doing和get used to doing主要的不同在于时间节点上，be used to doing一般是用在习惯之后，是”已经“习惯了，而get used to doing是习惯之前，”还没“习惯，要花时间去习惯，下面这个例句应该可以很好地说明两个词组的区别。</p>
<p>Tom wasn’t used to noise. It took him some time to get used to it.<br>I am well on the way to improving vocal technique<br>get accustomed<br>use you body as a way of making the speech more vivid and clear<br>gestures</p>
<pre><code>fantastic
fascinating
</code></pre>
<blockquote>
<p>usage</p>
</blockquote>
<pre><code>quite : The preformance is quite well
quiet : They lead a quiet life
</code></pre>
<pre><code> generous
 gorgeous
 prosperous
 prestigious
</code></pre>
<pre><code>corn
scorn
concorn
</code></pre>
<pre><code> delicate
 dedicate
 deduce
 
</code></pre>
<blockquote>
<p>virtue virus</p>
</blockquote>
<blockquote>
<p>stimulate 刺激 imitate 模仿</p>
</blockquote>
<blockquote>
<p>There is no viable alterntive</p>
</blockquote>
<blockquote>
<p>where have you been<br>where did you just go</p>
</blockquote>
<blockquote>
<p>it has been tow months since I arrived the Budapest<br>so-called<br>we examine the sacry process<br>crowd<br>of them all 表示其中一个或几个<br>all of them 表示所有<br>off to 将要去</p>
</blockquote>
<blockquote>
<p>how come 为什么；怎么会这样</p>
</blockquote>
<blockquote>
<p>how come是美国人常用的表达，意思是怎么会、为什么会这样。外国人不用how come表示怎么来的，怎么来的我们可以说，how do you get here。</p>
</blockquote>
<blockquote>
<p>how come的意思和why基本一致，但又有几点区别。</p>
</blockquote>
<pre><code>①how come一般适用于发生了什么事的场合。别人对你说how come，表示他不理解事情是怎么发生的，很希望得到你的解释。相比why，how come可以表达好奇和震惊的心情，语气要更加强烈。

②同时，how come更口语化，多用于生活交际。而why书面和口语都可以使用，使用范围更广。

③还有一个很重要的区别，大家千万要记住，why后面接的是疑问句，但是how come后面接的是陈述句的语序，千万不要搞错了。
</code></pre>
<blockquote>
<p>while others will hardly ever laugh at all<br>Have you ever been caught </p>
</blockquote>
<p><img src="/images/y-1.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>FLOPs</title>
    <url>/2022/06/26/FLOPs/</url>
    <content><![CDATA[<p><img src="/images/FLOPs.png"></p>
]]></content>
      <tags>
        <tag>FLOPs</tag>
      </tags>
  </entry>
  <entry>
    <title>Short-term prediction of stock market price based on GA optimization LSTM neurons</title>
    <url>/2021/04/01/GA/</url>
    <content><![CDATA[<p><img src="/images/3_1.jpg"> </p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract :"></a>Abstract :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">Long-Short Term Memory Network stands out from the financial sector due to its long-term memory predictability, however, the speed of subsequent operations is extremely slow, and the timeliness of the inability to meet market changes has been criticized. In this paper. Aiming at the shortcomings of the slow running of three gates in each neuron of LSTM in back propagation, we1 propose to use GA to optimize the internal weights of LSTM neurons to optimize the defect. In this experiment, GA optimization could not change the accuracy of the model, but it achieved better results than the original LSTM in terms of speed, and satisfied the demand of the future business field for rapid response to market changes in terms of timeliness.
</blockquote>
<h1 id="LSTM-Architecture"><a href="#LSTM-Architecture" class="headerlink" title="LSTM Architecture :"></a>LSTM Architecture :</h1><p>  <img src="/images/3_2.jpg"> </p>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results :"></a>Results :</h1><p> <img src="/images/3_3.jpg"> </p>
<h1 id="Innovation"><a href="#Innovation" class="headerlink" title="Innovation :"></a>Innovation :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">This paper proposes a GA optimization method for LSTM neurons. By comparing the running time of predecessor models, it is possible to overcome the shortcomings of slow operation of LSTM to a certain extent by optimizing the internal weight of neurons through GA update.
<p style="text-align:justify; text-justify:inter-ideograph; color:black"> In addition, this article does not discuss the generalization ability of the network and other parameters of the network at the same time. The research purpose is too single. However, for the short-term prediction of financial markets, the importance of research on the timeliness and advancing of the model is much higher than that of the generalized network model
</blockquote>
<hr>
<h1 id="Publish"><a href="#Publish" class="headerlink" title="Publish :"></a>Publish :</h1><h3 id="Conference-2018-2nd-International-Conference-on-Deep-Learning-Technologies"><a href="#Conference-2018-2nd-International-Conference-on-Deep-Learning-Technologies" class="headerlink" title="Conference : 2018 2nd International Conference on Deep Learning Technologies"></a>Conference : 2018 2nd International Conference on Deep Learning Technologies</h3><h3 id="Index-EI-Compendex-Scopus"><a href="#Index-EI-Compendex-Scopus" class="headerlink" title="Index : EI Compendex, Scopus"></a>Index : EI Compendex, Scopus</h3><p><img src="/images/3_4.jpg"> </p>
<h1 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration :"></a>Declaration :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph;color:black;font-size:20px"> This paper was published a long time ago, and it is not perfect from my current point of view.<br>
<p style="text-align:right;color:black;font-size:20px"> --&nbsp;Moule Lin </blockquote>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hierarchical</title>
    <url>/2021/12/02/Hierarchical/</url>
    <content><![CDATA[<blockquote>
<p>层次聚类算法 各种linkage</p>
</blockquote>
<p>基本工作原理<br>给定要聚类的N的对象以及N*N的距离矩阵(或者是相似性矩阵), 层次式聚类方法的基本步骤(参看S.C. Johnson in 1967)如下:</p>
<ol>
<li><pre><code>将每个对象归为一类, 共得到N类, 每类仅包含一个对象. 类与类之间的距离就是它们所包含的对象之间的距离.
</code></pre>
</li>
<li><pre><code>找到最接近的两个类并合并成一类, 于是总的类数少了一个.
</code></pre>
</li>
<li><pre><code>重新计算新的类与所有旧类之间的距离.
</code></pre>
</li>
<li><pre><code>重复第2步和第3步, 直到最后合并成一个类为止(此类包含了N个对象).
</code></pre>
<p>根据步骤3的不同, 可将层次式聚类方法分为几类: single-linkage, complete-linkage 以及 average-linkage 聚类方法等.</p>
</li>
</ol>
<p>single-linkage 聚类法(也称 connectedness 或 minimum 方法)：</p>
<p>类间距离等于两类对象之间的最小距离，若用相似度衡量，则是各类中的任一对象与另一类中任一对象的最大相似度。</p>
<p>complete-linkage 聚类法 (也称 diameter 或 maximum 方法)：</p>
<p>组间距离等于两组对象之间的最大距离。</p>
<p>average-linkage 聚类法：</p>
<p>组间距离等于两组对象之间的平均距离。</p>
<p>average-link 聚类的一个变种是R. D’Andrade (1978) 的UCLUS方法, 它使用的是median距离, 在受异常数据对象的影响方面, 它要比平均距离表现更佳一些.</p>
<p>这种层次聚类称为“凝聚”法，由于它迭代合并所有分类。也有一种“划分”层次聚类法，与“凝聚”相反，它先将所有对象放在同一类中，并不断划分成更小的类，划分法一般很少使用。</p>
<p>整个聚类过程其实是建立了一棵树，在建立的过程中，可以通过在第二步上设置一个阈值，当最近的两个类的距离大于这个阈值，则认为迭代可以终止。另外关键的一步就是第三步，如何判断两个类之间的相似度有不少种方法。这里介绍一下三种：</p>
<p>SingleLinkage：又叫做 nearest-neighbor ，就是取两个类中距离最近的两个样本的距离作为这两个集合的距离，也就是说，最近两个样本之间的距离越小，这两个类之间的相似度就越大。容易造成一种叫做 Chaining 的效果，两个 cluster 明明从“大局”上离得比较远，但是由于其中个别的点距离比较近就被合并了，并且这样合并之后 Chaining 效应会进一步扩大，最后会得到比较松散的 cluster 。</p>
<p>CompleteLinkage：这个则完全是 Single Linkage 的反面极端，取两个集合中距离最远的两个点的距离作为两个集合的距离。其效果也是刚好相反的，限制非常大，两个 cluster 即使已经很接近了，但是只要有不配合的点存在，就顽固到底，老死不相合并，也是不太好的办法。这两种相似度的定义方法的共同问题就是指考虑了某个有特点的数据，而没有考虑类内数据的整体特点。</p>
<p>Average-linkage：这种方法就是把两个集合中的点两两的距离全部放在一起求一个平均值，相对也能得到合适一点的结果。</p>
<p>average-linkage的一个变种就是取两两距离的中值，与取均值相比更加能够解除个别偏离样本对结果的干扰。</p>


	<div class="row">
    <embed src="https://moulelin.github.io/pdf/cluster.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>culster</tag>
      </tags>
  </entry>
  <entry>
    <title>Homogeneous</title>
    <url>/2022/01/26/Homogeneous/</url>
    <content><![CDATA[<p><img src="/images/homogeneous.png"> </p>
]]></content>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>MATI-Regression</title>
    <url>/2021/11/02/MATI-Regression/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/MATI-Regression.pdf" width="100%" height="550" type="application/pdf">
	</div>




<h1 id="L1-amp-L2-regularization"><a href="#L1-amp-L2-regularization" class="headerlink" title="L1 &amp; L2 regularization"></a>L1 &amp; L2 regularization</h1>

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/MATI-Regression.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>MTAI</tag>
      </tags>
  </entry>
  <entry>
    <title>Likelihood2</title>
    <url>/2022/02/24/Likelihood2/</url>
    <content><![CDATA[<blockquote>
<p>注意：高斯分布图x轴坐标是变量X的取值，纵坐标是概率<br>因此，这里得到误差l（打不了误差符号），最大误差的密度概率是因为&#x3D;》最大概率处l&#x3D;0， 同时我们追求的也是误差最小，无限接近0，所以这里要对误差l的PDF取最大值，因此，每个样本的最大概率（最大似然）累乘就是我们需要优化的结果。<br><img src="/images/max.png"> </p>
</blockquote>
]]></content>
      <tags>
        <tag>Likelihood</tag>
      </tags>
  </entry>
  <entry>
    <title>Monte</title>
    <url>/2022/03/17/Monte/</url>
    <content><![CDATA[<blockquote>
<p>引入概率密度函数的蒙特卡洛公式推导，是把p(x) 看作前面分数的密度概率函数，也就是对前面分数求期望，而期望可以通过对p（x）采样并平均得到<br><img src="/images/MCMC.png">  </p>
</blockquote>
]]></content>
      <tags>
        <tag>machine</tag>
      </tags>
  </entry>
  <entry>
    <title>RL3ways</title>
    <url>/2022/03/20/RL3ways/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/RL3.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>MC</title>
    <url>/2022/03/19/MC/</url>
    <content><![CDATA[<p><img src="/images/MC.png">  </p>
]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2022/07/06/STL/</url>
    <content><![CDATA[<h1 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h1><p><img src="/images/2022-07-06-18-35-07.png"><br><img src="/images/2022-07-06-18-35-33.png"><br><img src="/images/2022-07-06-18-36-02.png"></p>
<blockquote>
<p>stack和queue不提供iterator</p>
</blockquote>
<blockquote>
<p>set&#x2F;multiset<br>multiset是基于红黑树实现的</p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>ShiftCNN</title>
    <url>/2022/08/16/ShiftCNN/</url>
    <content><![CDATA[<h2 id="ShiftCNN-shifts-the-channels-based-on-the-shift-matrix-kernel"><a href="#ShiftCNN-shifts-the-channels-based-on-the-shift-matrix-kernel" class="headerlink" title="ShiftCNN shifts the channels based on the shift matrix(kernel)"></a>ShiftCNN shifts the channels based on the shift matrix(kernel)</h2><blockquote>
<p><strong>这里有疑问，因为代码里面好像用的都是一个移动方向，只是对于不同通道进行了固定的移动，不管用多少次这个ShiftConv层，移动都是固定的(相同channel数据移动位置是相同的)</strong></p>
</blockquote>
<ul>
<li><a href="#Shift">Shift</a></li>
<li><a href="#%E6%96%87%E7%AB%A0">文章</a></li>
</ul>
<h1 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h1><blockquote>
<p>这个操作就是移动不同通道（移动方向是固定的，对于channel相同的数据来说）<br><img src="/images/image.png.png"></p>
</blockquote>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><blockquote>
<p>To reduce the state space, we use a simple heuristic: di- vide the M channels evenly into DK2 groups, where each group of ⌊M&#x2F;DK2 ⌋ channels adopts one shift<br>(划分M和通道到M&#x2F;D^2中。每M&#x2F;D^2个通道共享一个shift的方向)</p>
</blockquote>
<blockquote>
<p>I.e.和e.g.都是拉丁语缩写，i.e.代表id est，意为“也就是说，即”（that is），e.g.代表exempli gratia，意思是“举个例子”（for example）<br>However, finding the optimal permutation, <strong>i.e</strong>., how to map each channel-m to a shift group, requires searching a <strong>combinatorially(组合地)</strong> large search space.</p>
</blockquote>
<blockquote>
<p>we introduce a <strong>modification(限制)</strong> to the shift operation that makes input and output invariant to channel order:  We denote a shift operation with channel permutation π as Kπ(<strong>这里不是很明白，K代表的是通道置换</strong>),</p>
</blockquote>
<blockquote>
<p>G ̃&#x3D;Pπ2(Kπ(Pπ1(F)))<br>wherePπi are permutation operators and◦ denotes operator composition(<strong>这里不明白，Pπ代表的是置换算子，但是Pπ(K)Pπ结合起来是整个Shift操作</strong>)</p>
</blockquote>
<blockquote>
<p><strong>因为shift是离散的，因此加入point-wise convolution P1(F)来进行参数更新，离散的不好进行权重更新，同时shift matrix也不会更新</strong></p>
</blockquote>
<blockquote>
<p>So long as the shift operation is sandwiched between two point-wise convolutions, different permutations of shifts are equivalent. Thus, we can choose an arbitrary permutation for the shift kernel, after fixing the number of channels for each shift direction.<br>(说Shift夹入两个PW中就，对于channel顺序就不影响了，事实上肯定会影响的)</p>
</blockquote>
<blockquote>
<p>This convolution <strong>comprises(包含)</strong> ..</p>
</blockquote>
]]></content>
      <tags>
        <tag>Shift</tag>
      </tags>
  </entry>
  <entry>
    <title>ShiftGCN</title>
    <url>/2022/08/17/ShiftGCN/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>GCN</tag>
      </tags>
  </entry>
  <entry>
    <title>TF-IDF</title>
    <url>/2022/01/04/TF-IDF/</url>
    <content><![CDATA[<p><img src="/images/TF-IDF.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Theory</title>
    <url>/2021/12/01/Theory/</url>
    <content><![CDATA[<h1 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h1>

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/probability.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
  </entry>
  <entry>
    <title>VCDimension</title>
    <url>/2022/02/10/VCDimension/</url>
    <content><![CDATA[<blockquote>
<p>注意这里的VC维度指的是只要存在一个不可分的点，比如四个点，一条直线存在无法分割的情况，那就VC维度就不是4，应该从3来看<br><img src="/images/CVDim.png"> </p>
</blockquote>
]]></content>
      <tags>
        <tag>Machine</tag>
      </tags>
  </entry>
  <entry>
    <title>across_loss</title>
    <url>/2022/03/29/across-loss/</url>
    <content><![CDATA[<p><img src="/images/cross_derivate.png"> </p>
]]></content>
      <tags>
        <tag>machine</tag>
      </tags>
  </entry>
  <entry>
    <title>apriori</title>
    <url>/2022/01/06/apriori/</url>
    <content><![CDATA[<p><img src="/images/apriori.png"> </p>
]]></content>
      <tags>
        <tag>apriori</tag>
      </tags>
  </entry>
  <entry>
    <title>copyC</title>
    <url>/2022/03/13/copyC/</url>
    <content><![CDATA[<p>浅拷贝和深拷贝<br>指针浅拷贝导致堆区的数据重复释放<br>问题：近期在做算法实验的时候碰到一个关于类指针赋值的问题，简单的指针之间的赋值只是把两个指针指向同一个地址，而我需要把每次算法执行完的类指针push_back进vector储存每次算法迭代的结果，如果每次都是存入同一个指针，就会出现vector中的类指针都指向同一个地址，这就让我想到了能不能进行类指针之间的赋值，两个类指针之间内容相同，但是指针指向的地址都不同，就是两个不同的指针。</p>
<p>定义</p>
<p>浅拷贝：按照我的理解就是，两类之间发生数据成员的赋值，如果只是简单数据类型之间的赋值，浅拷贝完全能够胜任，但是碰到有指针的时候，两个类之间浅拷贝，那么两个对象中的指针会指向同一个地址，那么析构函数执行的时候就会发生错误（同一指针释放了两次）。</p>
<p>深拷贝：在浅拷贝的基础上对指针拷贝进行处理，让两个类指针中的指针指向不同的区域，这样两个类指针虽然内容想到，但是是存储在内存的不同区域。<br>‘’’<br>class rect<br>{<br>public:</p>
<pre><code>rect();
rect(const rect *r);
~rect();
</code></pre>
<p>private:<br>    int width, height;<br>    int *p;<br>};<br>rect::rect(const rect *r)<br>{<br>    width &#x3D; r-&gt;width;<br>    height &#x3D; r-&gt;height;<br>    p &#x3D; new int;<br>    *p &#x3D; *(r-&gt;p);<br>}</p>
<p>rect::rect()<br>{<br>    p &#x3D; new int(100);<br>}</p>
<p>rect::~rect()<br>{<br>    if (p !&#x3D; NULL)<br>        delete p;<br>}<br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>    rect *rect1;<br>    rect *rect2;<br>    rect1 &#x3D; new rect;<br>    rect2 &#x3D; new rect(rect1);</p>
<pre><code>return 0;
</code></pre>
<p>}<br>‘’’<br>类指针和类内成员p指针都指向了不同的地址</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cout重载全局函数</title>
    <url>/2022/06/17/cout%E9%87%8D%E8%BD%BD%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="为什么c-中重载流操作符要用友元函数"><a href="#为什么c-中重载流操作符要用友元函数" class="headerlink" title="为什么c++中重载流操作符要用友元函数"></a>为什么c++中重载流操作符要用友元函数</h1><h2 id="作为成员函数的话，左操作数非得是自己不可"><a href="#作为成员函数的话，左操作数非得是自己不可" class="headerlink" title="作为成员函数的话，左操作数非得是自己不可"></a>作为成员函数的话，左操作数非得是自己不可</h2><blockquote>
<p>cout &lt;&lt; XXX 这种情况是cout在调用operator&lt;&lt;而不是XXX在调用operator&lt;&lt; 。<br>如果你要把operator&lt;&lt;设为成员函数就只能用 XXX &lt;&lt; cout 这种形式。</p>
</blockquote>
<p><strong>所以这样也是可以的，就是有违常理</strong></p>
<pre><code>struct point
&#123;
    int x;
    int y;

    point (int _x, int _y)
        : x(_x), y(_y)
    &#123;&#125;

    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os) const
    &#123;
        os &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot;;
        return os;
    &#125;
&#125;;

int main(int argc, const char* argv[])
&#123;
    point p1(1, 2);

    p1 &lt;&lt; std::cout; // 写法同p1.operator&lt;&lt;(std::cout);

    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cudaMemPitch</title>
    <url>/2022/06/28/cudaMemPitch/</url>
    <content><![CDATA[<h1 id="cudaMemPitch-is-for-tow-dimensions-matrix"><a href="#cudaMemPitch-is-for-tow-dimensions-matrix" class="headerlink" title="cudaMemPitch is for tow dimensions matrix"></a>cudaMemPitch is for tow dimensions matrix</h1><blockquote>
<p>cudaMallocPitch ( void** devPtr, size_t* pitch, size_t width, size_t height )<br>devPtr - Pointer to allocated pitched device memory<br>pitch - Pitch for allocation<br>width - Requested pitched allocation width (in bytes)<br>height - Requested pitched allocation height</p>
</blockquote>
<blockquote>
<p>cudaError_t cudaMemcpy2D	(	void * 	dst,<br>size_t 	dpitch,<br>const void * 	src,<br>size_t 	spitch,<br>size_t 	width,<br>size_t 	height,<br>enum cudaMemcpyKind 	kind	<br>)	</p>
</blockquote>
<blockquote>
<p>Parameters:<br>dst 	- Destination memory address<br>dpitch 	- Pitch of destination memory<br>src 	- Source memory address<br>spitch 	- Pitch of source memory<br>width 	- Width of matrix transfer (columns in bytes)<br>height 	- Height of matrix transfer (rows)<br>kind 	- Type of transfer</p>
</blockquote>
<pre><code>`The spitch is different when cudaMemcpyKind is different`

#include&lt;stdio.h&gt;
#include&lt;cuda.h&gt;
#include&lt;cuda_runtime.h&gt;
#include&lt;device_launch_parameters.h&gt;
#include&lt;conio.h&gt;

#define BLOCKSIZE_x 16
#define BLOCKSIZE_y 16

#define Nrows 3
#define Ncols 5

/*****************/
/* CUDA MEMCHECK */
/*****************/
#define gpuErrchk(ans) &#123; gpuAssert((ans), __FILE__, __LINE__); &#125;

inline void gpuAssert(cudaError_t code, char *file, int line, bool abort = true)
&#123;
    if (code != cudaSuccess)
    &#123;
        fprintf(stderr, &quot;GPUassert: %s %s %dn&quot;, cudaGetErrorString(code), file, line);
        if (abort) &#123; getch(); exit(code); &#125;
    &#125;
&#125;

/*******************/
/* iDivUp FUNCTION */
/*******************/
int iDivUp(int hostPtr, int b)&#123; return ((hostPtr % b) != 0) ? (hostPtr / b + 1) : (hostPtr / b); &#125;

/******************/
/* TEST KERNEL 2D */
/******************/
__global__ void test_kernel_2D(float *devPtr, size_t pitch)
&#123;
    int    tidx = blockIdx.x*blockDim.x + threadIdx.x;
    int    tidy = blockIdx.y*blockDim.y + threadIdx.y;

    if ((tidx &lt; Ncols) &amp;&amp; (tidy &lt; Nrows))
    &#123;
        float *row_a = (float *)((char*)devPtr + tidy * pitch);
        row_a[tidx] = row_a[tidx] * tidx * tidy;
    &#125;
&#125;

/********/
/* MAIN */
/********/
int main()
&#123;
    float hostPtr[Nrows][Ncols];
    float *devPtr;
    size_t pitch;

    for (int i = 0; i &lt; Nrows; i++)
        for (int j = 0; j &lt; Ncols; j++) &#123;
            hostPtr[i][j] = 1.f;
            //printf(&quot;row %i column %i value %f \n&quot;, i, j, hostPtr[i][j]);
        &#125;

    // --- 2D pitched allocation and host-&gt;device memcopy
    gpuErrchk(cudaMallocPitch(&amp;devPtr, &amp;pitch, Ncols * sizeof(float), Nrows));
    gpuErrchk(cudaMemcpy2D(devPtr, pitch, hostPtr, Ncols*sizeof(float), Ncols*sizeof(float), Nrows, cudaMemcpyHostToDevice));

    dim3 gridSize(iDivUp(Ncols, BLOCKSIZE_x), iDivUp(Nrows, BLOCKSIZE_y));
    dim3 blockSize(BLOCKSIZE_y, BLOCKSIZE_x);

    test_kernel_2D &lt;&lt; &lt;gridSize, blockSize &gt;&gt; &gt;(devPtr, pitch);
    gpuErrchk(cudaPeekAtLastError());
    gpuErrchk(cudaDeviceSynchronize());

    gpuErrchk(cudaMemcpy2D(hostPtr, Ncols * sizeof(float), devPtr, pitch, Ncols * sizeof(float), Nrows, cudaMemcpyDeviceToHost));

    for (int i = 0; i &lt; Nrows; i++) 
        for (int j = 0; j &lt; Ncols; j++) 
            printf(&quot;row %i column %i value %f \n&quot;, i, j, hostPtr[i][j]);

    return 0;    
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉熵损失函数详解</title>
    <url>/2020/11/02/crossentropy/</url>
    <content><![CDATA[<h1 id="交叉熵的数学原理—pytorch中的CrossEntropyLoss-函数"><a href="#交叉熵的数学原理—pytorch中的CrossEntropyLoss-函数" class="headerlink" title="交叉熵的数学原理—pytorch中的CrossEntropyLoss()函数"></a>交叉熵的数学原理—pytorch中的CrossEntropyLoss()函数</h1><p>对于二分类来说，我们使用的是Binary Cross Entropy Loss,公式如下：<br> <img src="/images/1_1.png"><br>因为ln后的数为负数，所以加负号，保证我们是优化最小（不然就要往最大值优化了）；<br>如当l&#x3D;1时（标签为正样本），此时Loss &#x3D; -logp, 我们要使p的值尽量大，loss才会尽量小，最好能到1，就代表分类正确了</p>
<h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><p><img src="/images/1_2.png"><br>这里的label会被展开为<strong>one-hot</strong>编码<br><strong>主要讨论图像像素级的分类</strong></p>
<pre><code># -*- coding: utf-8 -*-
&#39;&#39;&#39;
@File  : 多分类.py
@Author: Moule Lin
@Date  : 2020/11/1 17:53
@Github: https://github.com/moulelin
&#39;&#39;&#39;

&#39;&#39;&#39;
CrossEntropy 的原理
Pytorch中CrossEntropyLoss()函数的主要是将softmax-log-NLLLoss合并到一块得到的结果。

1、Softmax后的数值都在0~1之间，所以ln之后值域是负无穷到0。

2、然后将Softmax之后的结果取log，将乘法改成加法减少计算量，同时保障函数的单调性 。

3、NLLLoss的结果就是把上面的输出与Label对应的那个值拿出来(下面例子中就是：
将log_output\logsoftmax_output中与y_target对应的值拿出来)，去掉负号，再求均值。 
    
    Tip: CrossEntropyLoss() 会把Label变成ont-hot形式

&#39;&#39;&#39;
import torch
import torch.nn as nn


loss = nn.CrossEntropyLoss()# 使用默认参数
input_data = torch.randn(1,3,2,2,requires_grad=True) # 第一维度对应channel，CrossEntropy是针对channel进行的
target = torch.tensor([[0, 1],[2, 0]],dtype=torch.long).unsqueeze(0) # 对应2*2大小的矩阵，每个点都存在一个类别


print(input_data)

print(target.shape)
print(input_data.shape)
loss_item = loss(input_data,target)
print(loss_item)
# 上面是直接通过Cross Entropy，下面一步步实现


softmax_func=nn.Softmax(dim=1) # 将channel维度进行压缩到0-1
softmax_out = softmax_func(input_data)

print(&quot;经过softmax如下所示：&quot;)
print(softmax_out)
print(&quot;经过log如下所示：&quot;)
log_output=torch.log(softmax_out) # 取对数
print(log_output)

print(&quot;经过NLLLoss如下所示：&quot;)
nllloss_func=nn.NLLLoss()
nlloss_output=nllloss_func(log_output,target)
print(nlloss_output)

# import math
# loss = nn.CrossEntropyLoss()
# data = torch.randn(1,3,1,5,requires_grad=True)
# label = torch.empty((1,1,5),dtype=torch.long).random_(5)
# out = loss(data,label)
# print(data.shape)
# print(label.shape)
# print(out)
</code></pre>
<h3 id="输出如下："><a href="#输出如下：" class="headerlink" title="输出如下："></a>输出如下：</h3><pre><code>tensor([[[[-0.2493, -0.9333],
          [ 0.0676,  1.2035]],

         [[ 0.2987, -0.6044],
          [-0.1341,  0.0938]],

         [[-1.3529, -0.2693],
          [-0.3259, -0.7915]]]], requires_grad=True)
torch.Size([1, 2, 2])
torch.Size([1, 3, 2, 2])
tensor(0.9862, grad_fn=&lt;NllLoss2DBackward&gt;)
经过softmax如下所示：
tensor([[[[0.3266, 0.2308],
          [0.4013, 0.6823]],

         [[0.5650, 0.3207],
          [0.3280, 0.2249]],

         [[0.1083, 0.4484],
          [0.2707, 0.0928]]]], grad_fn=&lt;SoftmaxBackward&gt;)
经过log如下所示：
tensor([[[[-1.1189, -1.4660],
          [-0.9131, -0.3823]],

         [[-0.5709, -1.1371],
          [-1.1148, -1.4921]],

         [[-2.2225, -0.8020],
          [-1.3066, -2.3773]]]], grad_fn=&lt;LogBackward&gt;)
经过NLLLoss如下所示：
tensor(0.9862, grad_fn=&lt;NllLoss2DBackward&gt;)
</code></pre>
<blockquote>
<p>这里一共有四个像素点,分别是[[0, 1],[2, 0]]，对于第一个像素点来说，它的分类结果是0，输出为3类，即分为三类，所以会被展开为[1,0,0]<br>代表第一个元素的第0个通道上的数值是我想取出来的，这里就是-1.1189，同理，对于第二个像素点来说展开为[0，1，0]，取得-1.1371，第三个[0,0,1],取得-1.3066，第四个[1,0,0],取得-0.3823， 将这四个数取绝对值相加再除4，（1.1189+1.1371+1.3066+0.3823）&#x2F;4 &#x3D; 0.9862<br>所以说，对于一个图像来说，输入维度为B,C,W,H，label对应的维度就是B,1,W,H就可以</p>
</blockquote>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>emotion_behind_your_money_habits</title>
    <url>/2021/12/24/emotion-behind-your-money-habits/</url>
    <content><![CDATA[<blockquote>
<p>I’m good with numbers and using them to report what’s happening, but I’m also concerned with the full story behind those numbers, the part that gets lost in translation, the part that numbers can’t quite tell, the story that goes deeper than mere stratetgies for saving and earning money.</p>
</blockquote>
<p><img src="/images/emotional.png"> </p>
]]></content>
      <tags>
        <tag>ted</tag>
      </tags>
  </entry>
  <entry>
    <title>equilibria</title>
    <url>/2022/02/08/equilibria/</url>
    <content><![CDATA[<p><img src="/images/game01.png"> </p>
<p>举个例子吧如图所示：首先固定1<br>1选择C–&gt; 2最好选择C(-5&gt;-15)，<br>画上蓝色线条<br>1选择N–&gt; 2最好选择C(0&gt;-1)，画上蓝色线条<br>接下来固定2<br>2选择C–&gt; 1最好选择C(-5&gt;-15)，画上红色线条<br>2选择N–&gt; 1最好选择C(0&gt;-1)，画上红色线条得纯策略纳什均衡(-5,-5)</p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>forandrecursion</title>
    <url>/2022/04/21/forandrecursion/</url>
    <content><![CDATA[<blockquote>
<p>为什么要用for循环调用递归呢?<br>什么时候递归需要加一层for循环呢？</p>
</blockquote>
<h1 id="Answer：当子任务是被划分为-多层的子任务"><a href="#Answer：当子任务是被划分为-多层的子任务" class="headerlink" title="Answer：当子任务是被划分为  多层的子任务"></a>Answer：当子任务是被划分为  多层的子任务</h1><blockquote>
<p>比如全排列问题</p>
</blockquote>
]]></content>
      <tags>
        <tag>-algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>as从句</title>
    <url>/2022/09/24/as%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<p><img src="/images/as.jpeg"></p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>p18-function-like-class</title>
    <url>/2022/06/16/function-like-class/</url>
    <content><![CDATA[<ul>
<li><a href="#%E4%B8%B4%E6%97%B6%E5%87%BD%E6%95%B0">临时函数</a></li>
</ul>
<h1 id="临时函数"><a href="#临时函数" class="headerlink" title="临时函数"></a>临时函数</h1><pre><code>#include&lt;iostream&gt;

class temporary&#123;
public:
    temporary()&#123;
            std::cout &lt;&lt; &quot;temporary ctor&quot; &lt;&lt;std::endl;
    &#125;
    ~temporary()&#123;
        std::cout &lt;&lt; &quot;destory&quot;  &lt;&lt;std::endl;
    &#125;
    void fun()&#123;
        std::cout &lt;&lt; &quot;This is function output&quot;  &lt;&lt;std::endl;
    &#125;

&#125;;
int main()&#123;
    
    temporary ().fun();
    return 0;
&#125;
</code></pre>
<p><strong>output</strong>:</p>
<pre><code>temporary ctor
This is function output
destory
</code></pre>
<ul>
<li>建立一个没有命名的非堆（non-heap）对象，也就是无名对象时，会产生临时对象</li>
</ul>
<pre><code>Integer inte= Integer(5); //用无名临时对象初始化一个对象
</code></pre>
<ul>
<li>构造函数作为隐式类型转换函数时，会创建临时对象，用作实参传递给函数。</li>
</ul>
<pre><code>class Integer
&#123;
public:
    Integer(int i):m_val(i)&#123;&#125;
    ~Integer()&#123;&#125;
private:
    int m_val;
&#125;;
 
void testFunc(Integer itgr)
&#123;
    //do something
&#125;

int  i = 10;
testFunc(i);

会产生一个临时对象，作为实参传递到 testFunc 函数中。
</code></pre>
<ul>
<li>函数返回一个对象时，会产生临时对象。以返回的对象作为拷贝构造函数的实参构造一个临时对象。</li>
</ul>
<pre><code>Integer Func()
&#123;
    Integer itgr;
    return itgr;
&#125;
 
int main()
&#123;
    Integer in;
    in = Func();
&#125;
</code></pre>
<h1 id="Why-we-need-function-like-class"><a href="#Why-we-need-function-like-class" class="headerlink" title="Why we need function-like class?"></a>Why we need function-like class?</h1><ul>
<li>让类实例化之后的对象可以作为一个参数进行传递（可以随时修改这个类，但是不影响其他类或者函数）</li>
</ul>
<p><img src="/images/function-like-class.png"></p>
<ul>
<li>标准库中存在很多仿函数，并且会继承很多奇特的base classes</li>
</ul>
]]></content>
      <tags>
        <tag>-c++</tag>
      </tags>
  </entry>
  <entry>
    <title>likeihood</title>
    <url>/2021/12/17/likeihood/</url>
    <content><![CDATA[<p><img src="/images/likelihood.png"> </p>
]]></content>
      <tags>
        <tag>likelihood</tag>
      </tags>
  </entry>
  <entry>
    <title>list必须用自己的sort</title>
    <url>/2022/09/06/list%E5%BF%85%E9%A1%BB%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84sort/</url>
    <content><![CDATA[<h2 id="list-是object-orientated-programming-的典范，把数据（data）和-方法（method）绑定"><a href="#list-是object-orientated-programming-的典范，把数据（data）和-方法（method）绑定" class="headerlink" title="list 是object orientated programming 的典范，把数据（data）和 方法（method）绑定"></a>list 是object orientated programming 的典范，把数据（data）和 方法（method）绑定</h2><p><img src="/images/2022-09-06-14-01-14.png"></p>
<ul>
<li>list因为链表结构，不能随机访问，因此不能使用全局的sort，全局sort涉及到对iterator的随机访问</li>
</ul>
<h2 id="函数模板流程，先判断是stone，之后调用stone的重载符号-gt"><a href="#函数模板流程，先判断是stone，之后调用stone的重载符号-gt" class="headerlink" title="函数模板流程，先判断是stone，之后调用stone的重载符号&gt;"></a>函数模板流程，先判断是stone，之后调用stone的重载符号&gt;</h2><ul>
<li>作用在左边的变量中，这里就是 b._weight &gt; rsh(a)._weight</li>
</ul>
<p><img src="/images/2022-09-06-14-17-28.png"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>multiset</title>
    <url>/2022/09/05/mutiset/</url>
    <content><![CDATA[<p><img src="/images/2022-09-05-22-49-24.png"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2022/07/26/makefile/</url>
    <content><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>目标: 依赖<br>tab  命令</p>
<pre><code>a:b c
    @echo &quot;hello world&quot;
b:
    @echo &quot;hello b&quot;
c:
    @echo &quot;hello c&quot;
</code></pre>
<blockquote>
<p>output</p>
</blockquote>
<pre><code>hello b
hello c
hello world
</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>n-gram</title>
    <url>/2022/01/04/n-gram/</url>
    <content><![CDATA[<p><img src="/images/n-gram.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>p19-namespace</title>
    <url>/2022/06/16/namespace/</url>
    <content><![CDATA[<h1 id="不同开发团队取的类名冲突"><a href="#不同开发团队取的类名冲突" class="headerlink" title="不同开发团队取的类名冲突"></a>不同开发团队取的类名冲突</h1><p><img src="/images/namespace.png"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>note</title>
    <url>/2022/08/17/note/</url>
    <content><![CDATA[<p>所有通道像素的组合排列决定了这个像素的属性。同时这个像素点与周围像素也存在联系，通常来说，如果相邻两个像素点所有通道的欧式距离之差不小于某个阈值，可以认为是属于一类的<br>对通道进行卷积操作，</p>
<blockquote>
<p>想法：双重推理，首先构建一个建筑语义分割的算法来获得建筑（0-1），之后通过图生成算法，输入为用户指定出的点和分割出来的图片</p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Object detection algorithm based AdaBoost residual correction Fast R-CNN on network</title>
    <url>/2021/04/01/odfr/</url>
    <content><![CDATA[<p><img src="/images/4_1.jpg"> </p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract :"></a>Abstract :</h1><blockquote>
<p style="text-align:justify; text-justify:inter-ideograph; color:black">The rapid development of computer hardware has promoted the prosperity of computer vision. Target object detection is widely used in various industrial and commercial fields, and contour detection is the core of target object detection. In order to realize the object target contour recognition method based on computer vision with high accuracy, this paper takes the cattle face position determination as an example, Fast R-CNN as the object contour detection algorithm, and uses AdaBoost as the residual detector to improve the accuracy of the results. In the experiment, the LabelImg tool marks the positional coordinates of the facial contours of 1000 cows, and at the same time, SURF algorithm was used to extract image features. The AdaBoost cascade classifier trained 900 positive images and 100 negative images. Fast R-CNN used the original images and the labeled images as training sets respectively. The results show that in the image set with resolution of 866*652 (pixels), the target detection accuracy of using Fast R-CNN is 91.6%, and AdaBoost as the residual detector will improve the accuracy to 96.76%. Meanwhile, by comparing the two training data sets of Fast r-cnn, the image labeled by LabelImg is used as the Fast r-cnn training set to obtain the optimal accuracy of 96.9% and the optimal recognition time of single picture of 0.35s.
</blockquote>
<h1 id="Image-Label"><a href="#Image-Label" class="headerlink" title="Image Label :"></a>Image Label :</h1><p>  <img src="/images/4_2.jpg"> </p>
<h1 id="Reslut"><a href="#Reslut" class="headerlink" title="Reslut :"></a>Reslut :</h1><p>  <img src="/images/4_3.jpg">  </p>
<hr>
<h1 id="Publish"><a href="#Publish" class="headerlink" title="Publish :"></a>Publish :</h1><h3 id="Conference-2019-3nd-International-Conference-on-Deep-Learning-Technologies"><a href="#Conference-2019-3nd-International-Conference-on-Deep-Learning-Technologies" class="headerlink" title="Conference : 2019 3nd International Conference on Deep Learning Technologies"></a>Conference : 2019 3nd International Conference on Deep Learning Technologies</h3><h3 id="Index-EI-Compendex-Scopus"><a href="#Index-EI-Compendex-Scopus" class="headerlink" title="Index : EI Compendex, Scopus"></a>Index : EI Compendex, Scopus</h3><p><img src="/images/4_4.jpg"> </p>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>Detect</tag>
      </tags>
  </entry>
  <entry>
    <title>operator赋值为什么返回引用</title>
    <url>/2022/03/13/operator%E8%B5%8B%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>一个自定义类，如果没有重载其&#x3D;运算符，那么编译器将自动生成一个。但是此编译器自动生成的重载函数可能不安全。这是因为它采用了所谓的“浅拷贝”，也就是对于指针而言，它拷贝的是指针的值，而不是其指向的内存空间。那么这个内存空间就有了两个指针指向它，且类对象要析构两次，但是内存空间只能被释放一次，那么第二次就会出现访问错误。</p>
<p>　　要避免这种“浅拷贝”问题，就需要重载&#x3D;运算符。这是一个二元运算符，函数名和参数比较容易确定，重点是其返回类型。一般来说，要返回一个类的引用类型。这是因为要能实现所谓的“链式编程”。我存在过的疑问是，为什么要返回一个引用，才能实现所谓的“链式编程”呢？这里从代码出发，进行思考与总结。</p>
<p>复制代码<br>class Student<br>{<br>public:<br>    Student(const char* name);~Student();<br>    Student&amp; operator&#x3D;(const Student &amp;student);private:<br>    char *m_name;<br>};<br>复制代码<br>复制代码<br>&#x2F;&#x2F;测试代码<br>Student s1(“Lee”);<br>Student s2(“Diwen”);<br>Student s3(“Tom”);</p>
<p>&#x2F;&#x2F;先执行s2 &#x3D; s1, 即执行 s2.operator&#x3D;(s1), 返回的是s2的引用<br>&#x2F;&#x2F;然后执行s3 &#x3D; s2, 即执行 s3.operator&#x3D;(s2)<br>s3 &#x3D; s2 &#x3D; s1;<br>复制代码<br>　　&#x3D;的链式编程执行顺序是从右向左的。因此右边需要返回一个Student类型的对象，是肯定的。那么问题是，为何要返回一个引用呢？</p>
<p>　　观察一下重载&#x3D;运算符的函数，参数类型是一个常量引用，也即是说传进去的实参必须是一个左值。而如果返回类型是Student，那么返回的就是一个匿名对象（右值），作为链式编程，此返回值（右值）又要作为实参传进去，那么显然不行(不加const不行，加了是可以的)。<br>const引用可以绑定到右值，而重载的赋值运算符返回一个引用当然是为了避免没有意义的拷贝了。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>other和others</title>
    <url>/2022/06/21/other%E5%92%8Cothers/</url>
    <content><![CDATA[<h2 id="other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others-x3D-other-复数名词。others通常为代词"><a href="#other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others-x3D-other-复数名词。others通常为代词" class="headerlink" title="other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others&#x3D;other+复数名词。others通常为代词"></a>other和others均表示不确指意义，其中other后可以修饰名词，而others后不能再接名词，两者的关系可描述为：others&#x3D;other+复数名词。others通常为代词</h2><blockquote>
<p>He never thinks of <code>others</code>. 他从来不为别人着想。</p>
</blockquote>
<blockquote>
<p>I don’t like these books. Show me some others. 我不喜欢这些书，再拿一些给我看。</p>
</blockquote>
<p>第一句中的others&#x3D;other people，意为“其他人”“别人”，泛指其他所有人；第二句中的others&#x3D;other books，意为“其他的书”。</p>
<p>但是，若要表示确指意义，我们就在other和others前面使用定冠词，同样地，other后可以修饰名词，而others后不能再接名词，两者的关系仍然存在the others&#x3D;the other+复数名词。如：</p>
<blockquote>
<p>I started last in the race but I soon caught up with the others. 我在赛跑中最后一个起跑，但不久就赶上了其他人。</p>
</blockquote>
<p>句中的the others&#x3D;the other people，意为“其他人”，其中的定冠词特指参加赛跑的所有其他人。</p>
<blockquote>
<p>注意：the other后除接复数名词外，还可以接单数名词，此时不能用the others代替。如：</p>
</blockquote>
<p>This seat is free; the other seat is taken. 这个座位空着，那个座位有人。</p>
<h2 id="常用惯用表达"><a href="#常用惯用表达" class="headerlink" title="常用惯用表达"></a>常用惯用表达</h2><p>①<code>one...the other</code>表示“(两者中的)一个……另一个……”。如：</p>
<p>What I say goes in at one ear and out at the other. 我说话他是一只耳朵进，另一只耳朵出。</p>
<p>②<code>one...the others</code>表示“(好几个中的)一个……其余都……”。如：</p>
<p>Of their five children, one is in China and the others are abroad. 他们有五个小孩，一个在中国，其余的都在国外。</p>
<p>注：若为三者，想要表示“一个……另一个……剩下的一个……”，可用one…another…the other [the third…]；若为四者，可用one…another…another [a third]…the other [the fourth, the last]。</p>
<p>③<code>some...the others</code>表示“一些……其他一些的……”。如：</p>
<p>The search party was divided into two groups. Some went to the right, the others went to the left. 搜寻小组一分为二，一部分向右，另一部分人向左。</p>
<p>④<code>some…others</code>表示“有的……有的……”。如：</p>
<p>Some people build while others destroy. 有些人建设而另一些人则破坏。</p>
<p>注：该结构也可说成some…some。如：</p>
<p>Some of us agree, some disagree. 我们有些人同意，有些人不同意。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>p27variadic-template</title>
    <url>/2022/06/18/p27variadic-template/</url>
    <content><![CDATA[<h1 id="不定模版参数"><a href="#不定模版参数" class="headerlink" title="不定模版参数"></a>不定模版参数</h1><pre><code>template &lt;class T1, class... args&gt;
void test(T1 t, args&amp;... arg)&#123;

&#125;
test(1,2,&#39;a&#39;,&#39;c&#39;); 
</code></pre>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><pre><code>list&lt;string&gt; c;
auto ite = find(c.begin(), c.end(),traget);
//auto声明变量的时候必须就赋值
auto ite; //这行和下一行是不对的
itr = find(c.begin(), c.end(),traget);

or
list&lt;string&gt;::interate ite = find(c.begin(), c.end(),traget);
</code></pre>
<h1 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h1><pre><code>for (decl:coll)&#123;
    statement
&#125;
for(auto elem:vec)&#123; //这每个拿出来赋值到左边
    // 右边是容器，左边是输出的每个数
    cout &lt;&lt; elem &lt;&lt; endl;
&#125;
//用引用也行
for(auto&amp; elem:vec)&#123;
    // 右边是容器，左边是输出的每个数
    cout &lt;&lt; elem &lt;&lt; endl;
&#125;

for (int i:&#123;1,2,3,4,5&#125;)&#123;
    cout &lt;&lt; i;
&#125;
</code></pre>
<h1 id="传引用和传value是相同的signature"><a href="#传引用和传value是相同的signature" class="headerlink" title="传引用和传value是相同的signature"></a>传引用和传value是相同的signature</h1><p>signature指的是除了返回值类型的余下部分<br>double image(const double&amp; in) const {}<br>double image(const double in) const {}</p>
<blockquote>
<p>上面两个是相同的，不能同时存在</p>
</blockquote>
<p> notes：image() 后的const也是signature的一部分，<br> double image(const double&amp; in) const {}<br>double image(const double in) {}</p>
<blockquote>
<p>这样是可以共存的</p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>oral_practices</title>
    <url>/2021/11/01/oral-practices/</url>
    <content><![CDATA[<p>a new way to get personalized, relevant ideas, delivered right to your inbox.</p>
]]></content>
  </entry>
  <entry>
    <title>p33const</title>
    <url>/2022/06/19/p33const/</url>
    <content><![CDATA[<h1 id="const-规则"><a href="#const-规则" class="headerlink" title="const 规则"></a>const 规则</h1><p><img src="/images/const.png"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>p22Member-Template</title>
    <url>/2022/06/17/p22Member-Template/</url>
    <content><![CDATA[<h2 id="模版内还有模版，一般用于构造函数中，"><a href="#模版内还有模版，一般用于构造函数中，" class="headerlink" title="模版内还有模版，一般用于构造函数中，"></a>模版内还有模版，一般用于构造函数中，</h2><ul>
<li>把草鱼和麻雀用于对鱼类和鸟类的初始化（作为构造函数传入）</li>
<li>这里的T1 first 能成功，是因为first是草鱼，是继承了鱼这个类的,也叫up-cast</li>
</ul>
<pre><code>// for smart pointer
template&lt;class _Tp&gt;
class shared_pte:public _shared_ptr&lt;_Tp&gt;&#123;

    ...
    template&lt;class _Tp1&gt;
    explicit shared_ptr(const _Tp1* _p):_shared_ptr&lt;_Tp&gt;(_p)&#123;&#125;
&#125;
shared_ptr&lt;Base1&gt;sptr(new Derived1);
</code></pre>
<ul>
<li>为了让构造函数更有弹性<br><img src="/images/member-template.png"></li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>probability</title>
    <url>/2022/06/22/probability/</url>
    <content><![CDATA[<h2 id="68-95-99"><a href="#68-95-99" class="headerlink" title="68-95-99"></a>68-95-99</h2><ul>
<li>During one standard, it has 68% probability in it.</li>
<li>During tow standards, it has 95% probability in it.</li>
<li>During three standards, it has 99% probability in it.</li>
</ul>
]]></content>
      <tags>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title>pronounce</title>
    <url>/2021/11/06/pronounce/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="https://moulelin.github.io/pdf/pronounce.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>pronounce</tag>
      </tags>
  </entry>
  <entry>
    <title>review-paper</title>
    <url>/2022/06/17/review-paper/</url>
    <content><![CDATA[<p>Reviews:</p>
<ul>
<li><a href="#MUMLP">MUMLP</a></li>
<li><a href="#CUGCN">CUGCN</a></li>
</ul>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<pre><code> It records all my papers reviews and certainly can thereby help me to improve my next 
 academic writing according those negative comments
</code></pre>
<h2 id="MUMLP"><a href="#MUMLP" class="headerlink" title="MUMLP"></a>MUMLP</h2><blockquote>
<p>Comments to the Author<br>This paper proposes a Multi-Scale U-shape Multi-Layer Perceptron (MUMLP) model. This method includes the designed MSC (Multi-Scale Channel) block and the UMLP (U-shape Multi-Layer Perceptron) structure. Some experiments are conducted to analyze the effectiveness of the proposed method. The main comments are</p>
</blockquote>
<p><strong>Reviewer: 1</strong></p>
<ol>
<li><pre><code>For the background, it lacks some key literatures about the hyperspectral image, which can refer to 10.1109/TGRS.2016.2583219 and 10.1109/LGRS.2019.2936652.
</code></pre>
<ol start="2">
<li><pre><code>Please rewrite the contributions to highlight the innovation. 
</code></pre>
<ol start="3">
<li><pre><code>Table I and II can be combined to show the classification results of each class. 
</code></pre>
<ol start="4">
<li><pre><code>For the experimental results, please enhance analysis the reason why the proposed method can achieve better results.
</code></pre>
<ol start="5">
<li><pre><code>Please demonstrate the effectiveness of each module in the proposed architecture.
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>Reviewer: 2</strong></p>
<ol>
<li>Since all the experiments are about image classification, and classification has different meaning compared with identification, change your title.</li>
<li>Main contribution of a paper should focus on the highlighted novelty, not the experimental results in numbers, refine the first two contributions and delete the last one.</li>
<li>Move Fig.2 and Table 1 into next pages.</li>
<li>Acknowledgement part is missing, at least acknowledge the data provider.</li>
</ol>
<hr>
<h2 id="CUGCN"><a href="#CUGCN" class="headerlink" title="CUGCN"></a>CUGCN</h2><blockquote>
<p>Associate Editor<br>Comments to the Author:<br>The expert reviewers have raised some major issues, particularly regarding the experimental section. Additionally, they asked for more clarification on the novelty of the proposed method compared with the state-of-the-art. I have some concerns myself that I mentioned below. I encourage the authors to apply the major changes and provide a point-by-point response letter addressing all the concerns.</p>
</blockquote>
<p><strong>Editor</strong></p>
<ol>
<li>The datasets used are all old. Please evaluate your method using newer benchmark datasets such as Houston 2013 and 2018.</li>
<li>Please provide the classification maps for all datasets. To save up space the authors can only select a few methods which provide the highest accuracies for the visual comparisons of the final maps.  </li>
<li>Please provide the hyperparameter analysis. How sensitive is the proposed method to the selection of hyperparameters?</li>
<li>Please provide citations for the competing methods used in the experiments. Additionally, I recommend the authors provide a comparison with an advanced shallow feature extraction technique such as OTVCA (see “Feature Extraction for Hyperspectral Imagery: The Evolution From Shallow to Deep: Overview and Toolbox”).</li>
<li>Please provide more detail regarding the selection of training samples.</li>
<li>Please provide the processing time and compare it to the competing methods.</li>
</ol>
<p><strong>reviewer 1</strong></p>
<blockquote>
<p>This paper presents a new model, named the Context-Aware Attentional Graph U-Net (CAGU), to improve interclass variabilities and interclass similarities when classifying hyperspectral data. In general, the paper is interesting since it provides some technical novelties within the remote sensing field. However, there are still some points about the work that should be improved before publication.</p>
</blockquote>
<ol>
<li><p>(Page 1, Line 25, Right) Please, define the acronyms before their first usage.</p>
</li>
<li><p>(Page 2, Line 57, Left) The authors should better motivate the use of a U-Net model with respect to other classification architectures.</p>
</li>
<li><p>(Page 2, Line 26, Right) Please, try to be more specific when detailing the contributions of the work. For instance, it is not a good idea describing Fig.1 or talking about the conducted experiments as contributions.</p>
</li>
<li><p>(Page 3, Line 37, Right) Please, try to join the paragraphs of this section when they are very short.</p>
</li>
<li><p>(Page 3, Line 53, Right) Do the authors think that it would be possible to consider alternative kernel sizes? Please, provide more information about this.</p>
</li>
<li><p>(Page 4, Line 20, Right) Please, try to better clarify the GRU model here. I think the writing is a little obfuscated. It would be also good to include some visual data here.</p>
</li>
<li><p>(Page 5, Line 25, Left) The considered sampling strategy is not clear. What is the rationale behind it?</p>
</li>
<li><p>(Page 5, Line 44, Left) Please, provide the references of the considered competitors.</p>
</li>
<li><p>(Page 5, Line 52, Right) Please, explain here the insights why the proposed approach is outperforming the other competitors.</p>
</li>
<li><p>Please, revise the whole writing carefully:<br>(Page 3, Line 54, Right) “Copy and crop operation combines”<br>(Page 4, Line 30, Left) “an Tesla”</p>
</li>
</ol>
<p><strong>Reviewer 2:</strong></p>
<p>Comments to the Author</p>
<blockquote>
<p>According to the submitted manuscript, my concerns are as follows.</p>
</blockquote>
<ol>
<li>The full classification maps are expected to be given.</li>
<li>Why is there only a classification map of Salinas dataset? If possible, please give the classification maps of other datasets.</li>
<li>In Salinas dataset, why is the 2nd order CAGU higher than the 1st one with 10% of the sampled data? There is no such situation in the Pavia data set and the Indian pines data set?</li>
<li>Please give the accuracy and loss function curves of the training and validation sets of the Pavia data set and the Indian pines data set.</li>
<li>In the experiment, the latest hyperspectral image algorithm based on graph convolutional network should be added to show the superiority of this algorithm.</li>
</ol>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy</title>
    <url>/2021/10/31/scrapy/</url>
    <content><![CDATA[<h2 id="span如果中间夹了其他的span。比如"><a href="#span如果中间夹了其他的span。比如" class="headerlink" title="span如果中间夹了其他的span。比如"></a>span如果中间夹了其他的span。比如</h2><pre><code>&lt;span&gt; &lt;span&gt;aa &lt;/span&gt; &lt;span&gt;bb &lt;/span&gt;cc&lt;/span&gt;
</code></pre>
<blockquote>
<p>adpote [-1] to acquire “cc” if I want to get it instead of text() directly<br>amount4 &#x3D; ingredient.xpath(‘span[@class&#x3D;”recipe__list-qty”]&#x2F;text()’)[-1].get()</p>
</blockquote>
]]></content>
      <tags>
        <tag>spacpy</tag>
      </tags>
  </entry>
  <entry>
    <title>self-attention</title>
    <url>/2022/01/02/self-attention/</url>
    <content><![CDATA[<p><img src="/images/attention.png"> </p>
]]></content>
      <tags>
        <tag>attention</tag>
      </tags>
  </entry>
  <entry>
    <title>shardptrCirculate</title>
    <url>/2022/03/04/shardptrCirculate/</url>
    <content><![CDATA[<blockquote>
<p>定义对象用强智能指针，引用对象的时候用弱智能指针<br><img src="/images/shardptrcirculate.png">  </p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>silhouette</title>
    <url>/2021/12/04/silhouette/</url>
    <content><![CDATA[<p><img src="/images/silhouette.png"> </p>
]]></content>
      <tags>
        <tag>intr</tag>
      </tags>
  </entry>
  <entry>
    <title>smartpointer</title>
    <url>/2022/03/04/smartpointer/</url>
    <content><![CDATA[<p><img src="/images/smartPointer.png"> </p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>sparse</title>
    <url>/2022/07/02/sparse/</url>
    <content><![CDATA[<h1 id="How-to-prune-in-MLP"><a href="#How-to-prune-in-MLP" class="headerlink" title="How to prune in MLP?"></a>How to prune in MLP?</h1><p><img src="/images/2022-07-04-01-57-10.png"></p>
<ul>
<li>sets the connection weight whose lower than threshold as 0<br><img src="/images/2022-07-04-02-03-25.png"></li>
</ul>
<h1 id="Prune-for-CNN"><a href="#Prune-for-CNN" class="headerlink" title="Prune for CNN"></a>Prune for CNN</h1><p><img src="/images/2022-07-04-02-16-55.png"></p>
]]></content>
      <tags>
        <tag>sparse</tag>
      </tags>
  </entry>
  <entry>
    <title>p23specialization</title>
    <url>/2022/06/17/specialization/</url>
    <content><![CDATA[<h1 id="Full-specialization"><a href="#Full-specialization" class="headerlink" title="Full specialization"></a>Full specialization</h1><pre><code>template &lt;class key&gt;
class hash&#123;&#125;

template&lt;&gt;
class hash&lt;char&gt;&#123;&#125;

template&lt;&gt;
class hash&lt;int&gt;&#123;&#125;

template&lt;&gt;
class hash&lt;long&gt;&#123;
    size_t operator() (const long x)&#123;
        return x;
    &#125;
&#125;

cout&lt;&lt; hash&lt;long&gt;() (100);
//先创建一个临时对象，之后调用（）重载

</code></pre>
<blockquote>
<p>full specialization aims to specialize some type.<br>for exampl:<br><strong>this is a function for judging equality of two members</strong></p>
</blockquote>
<pre><code>template&lt;class T&gt;
bool Isequal(T&amp; p1, T&amp; p2)&#123;
    return p1 == p2;
&#125;
</code></pre>
<p><strong>But it does’t work for string. We need to override this special type</strong></p>
<pre><code>
template&lt;&gt;
bool Isequal&lt;char*&gt; (char* p1, char* p2)&#123;	
    return strcmp(p1, p2) == 0;
&#125;
</code></pre>
<ul>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</li>
</ul>
<p>注意如果是函数模版，就不需要写&lt;&gt;</p>
<pre><code>template &lt;class T&gt;
T max(const T lhs, const T rhs)&#123;   
    return lhs &gt; rhs ? lhs : rhs;
&#125;

template &lt;&gt;
int max(const int lhs, const int rhs)&#123;   
    return lhs &gt; rhs ? lhs : rhs;
&#125;
//这是因为编译器根据int max(const int, const int)的函数签名可以推导出来它是T max(const T, const T)的特化。
</code></pre>
<blockquote>
<p>Note that if specialization funtion does’t have arugements. It has various interpretation. For example</p>
</blockquote>
<pre><code>template &lt;class T&gt;
void f()&#123; T d; &#125;

template &lt;&gt;
void f()&#123; int d; &#125;

此时编译器不知道f()是从f&lt;T&gt;()特化来的，编译时会有错误：

error: no function template matches function template specialization &#39;f&#39;
这时我们便需要显式指定&quot;模板实参&quot;：

template &lt;class T&gt;
void f()&#123; T d; &#125;

template &lt;&gt;
void f&lt;int&gt;()&#123; int d; &#125;
</code></pre>
<hr>
<h2 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization (偏特化)"></a>partial specialization (偏特化)</h2><ul>
<li>arguments (参数的个数上)</li>
<li>range: shrink the range. For example, arbitary type to pointer (任意类型的变为任意指针类型)</li>
</ul>
<p>For arguments:</p>
<blockquote>
<p>类似于全特化，偏特化也是为了给自定义一个参数集合的模板，但偏特化后的模板需要进一步的实例化才能形成确定的签名。 值得注意的是函数模板不允许偏特化，</p>
</blockquote>
<pre><code>template &lt;class T1, class T2&gt;
class A&lt;T1, T2&gt;&#123;
    ...
&#125;;
template &lt;class T2&gt;
class A&lt;int, T2&gt;&#123;
    ...
&#125;;


函数模板是不允许偏特化的，下面的声明会编译错：

template &lt;class T1, class T2&gt;
void f()&#123;&#125;

template &lt;class T2&gt;
void f&lt;int, T2&gt;()&#123;&#125;


但函数允许重载，声明另一个函数模板即可替代偏特化的需要：

template &lt;class T2&gt;
void f()&#123;&#125;              // 注意：这里没有&quot;模板实参&quot;

多数情况下函数模板重载就可以完成函数偏特化的需要，一个例外便是std命名空间。 std是一个特殊的命名空间，用户可以特化其中的模板，但不允许添加模板（其实任何内容都是禁止添加的）
</code></pre>
<p><strong>For range:</strong></p>
<pre><code>template &lt;class T&gt;
class A&#123;&#125;
template &lt;class U&gt;
class A&lt;U*&gt;&#123;&#125;
// we limit if the type is pointer thereby goes second class

A&lt;string&gt; a;

A&lt;string*&gt; b;
</code></pre>
<p>这个设计是为了如果针对指针要做不同的处理，就使用这个偏特化</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>stl全局</title>
    <url>/2022/06/29/stl%E5%85%A8%E5%B1%80/</url>
    <content><![CDATA[<h1 id="C-函数或者命名空间前面加"><a href="#C-函数或者命名空间前面加" class="headerlink" title="C++函数或者命名空间前面加::"></a>C++函数或者命名空间前面加::</h1><ul>
<li>函数前面 ::find() 表示这个是全局的函数，不是这个作用域下的函数<br><img src="/images/2022-06-29-16-13-57.png"><blockquote>
<p>比如这里的 ::find()。这个是STL的algorithm中的函数，虽然这里如果不用:: , 编译器没有找到find也会到全局，但是加入会让代码更清晰</p>
</blockquote>
</li>
<li>jj01::test_array() &#x3D; 这个就是命名空间</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>subjunctive</title>
    <url>/2022/03/06/subjunctive/</url>
    <content><![CDATA[<h2 id="The-president-flanked-by-Secretary-of-State-John-Kerry-and-vice-President-Joe-Biden-down-played-the-claimed-economic-benefits-of-the-pipeline-arguing-it-wouldn’t-have-lowered-U-S-gas-prices-created-long-term-jobs-or-reduced-U-S-dependency-on-foreign-energy"><a href="#The-president-flanked-by-Secretary-of-State-John-Kerry-and-vice-President-Joe-Biden-down-played-the-claimed-economic-benefits-of-the-pipeline-arguing-it-wouldn’t-have-lowered-U-S-gas-prices-created-long-term-jobs-or-reduced-U-S-dependency-on-foreign-energy" class="headerlink" title="The president, flanked by Secretary of State John Kerry and vice President Joe Biden, down played the claimed economic benefits of the pipeline, arguing it wouldn’t have lowered U.S. gas prices, created long-term jobs or reduced U.S. dependency on foreign energy."></a>The president, flanked by Secretary of State John Kerry and vice President Joe Biden, down played the claimed economic benefits of the pipeline, arguing it wouldn’t have lowered U.S. gas prices, created long-term jobs or reduced U.S. dependency on foreign energy.</h2><blockquote>
<p>wouldn’t have done 表示不会做某事，但是实际上做了。文章中的意思是本来不会降低美国的油气价格。</p>
</blockquote>
<p>would have done</p>
<p>是一个固定虚拟语气的用法。</p>
<p>表示对过去事情的假设，意为“本来想做、要做但没做”，使用时大多会给出导致没做成或会这样做的条件。<br>英汉例句1：</p>
<p>If I had a chance，I would have set off on a journey round the world.<br>要是有机会，我早就环游世界了。（也可译为对现在的虚拟“要是有机会，我会环游世界”）</p>
<p>英汉例句2：</p>
<p>I would have told you the story about him, but you were not home.</p>
<p>我本来可以告诉你关于他的故事，但是你不在家。（由于：你不在家”这样的条件下，没有告诉关于他的的故事。）</p>
<p>5.would have done与if连用</p>
<p>例句：If I hadn’t been busy that day, I would have gone there with them.</p>
<p>如果那天我不忙，我会和他们一起去那儿。（事实上表示没有由于忙，而没有去。）</p>
<p>在这里也可以不用if</p>
<p>如：I was busy that day. Otherwise I would have gone there with them. </p>
<p>我那天很忙，否则，我就和他们一起去那儿了。</p>
<p>6.文章中lower 在这里作为动词，“降低”的意思。<br><img src="/images/subjunctive.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>t5-假设检验</title>
    <url>/2022/06/22/t5%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<p><img src="/images/p5.png"></p>
]]></content>
      <tags>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title>template-template-paramenter</title>
    <url>/2022/06/17/template-template-paramenter/</url>
    <content><![CDATA[<h1 id="模版参数中包含模版"><a href="#模版参数中包含模版" class="headerlink" title="模版参数中包含模版"></a>模版参数中包含模版</h1><ul>
<li>允许模板参数本身也是一个类模板，这可能会很有用。我们将继续以stack类模板作为例子</li>
</ul>
<pre><code>template &lt;class T1, template&lt;class T2&gt; 
class Container&gt;

class XCls&#123;

    private:
    Container&lt;T&gt; c;
    public:
    ...
&#125;
template&lt;class T&gt;
using Lst = List&lt;T,allocator&lt;T&gt;&gt;;


XCls&lt;string, Lst&gt; mylst;
</code></pre>
<blockquote>
<p>由于Stack类模板的声明中第二个参数是一个类型（typename Container），所以我们通过Stack&lt;int, std::deque<int>&gt;定义一个具体的栈类型时，第二个参数传递std::deque<int>，而不能是std::deque。上述定义中我们一共把int写了两遍，而这种重复是一种必然的重复。</p>
</blockquote>
<p>为了避免上述重复，我们可以让Stack的第二个参数直接是一个模板，而不再是一个具体类型。</p>
<pre><code>template&lt;typename T,
         template&lt;typename&gt; class Container = std::vector&gt;
struct Stack
&#123;
    void push(const T&amp; elem)
    &#123;
        elems.push_back(elem);
    &#125;

    T pop()
    &#123;
        if(empty()) throw std::out_of_range(&quot;Stack&lt;&gt;::pop: empty!&quot;);

        auto elem = elems.back();
        elems.pop_back();
        return elem;
    &#125;

    bool empty() const
    &#123;
        return elems.empty();
    &#125;

private:
    Container&lt;T&gt; elems;
&#125;;
</code></pre>
<blockquote>
<p>如上Stack类模板的第二个参数变为template<typename> class Container，它的名字仍旧是Container，但是类型变为一个模板，这个模板具有一个类型参数。由于Container自身的模板形参名字没有被使用，所以我们可以省略。按照标准这里声明Container前的关键字只能是class，不能是typename。最后，模板的模板参数也可以有默认值，这里我们设置为std::vector。</p>
</blockquote>
<p>有了上面的定义，我们期望可以这样使用Stack：Stack&lt;int, std::deque&gt; intStack，但编译器却给了我们一个教训。</p>
<p>std::deque类模板在stl库中的定义有两个类型参数，第一个参数是元素类型，第二个参数是分配器allocator的类型。虽然std::deque的第二个类型参数有默认值，但是当编译器使用std::deque替换Container时却会严格匹配参数，默认值被忽略了。</p>
<p>我们修改Stack的定义如下：</p>
<pre><code>template&lt;typename T,
         template&lt;typename Elem, typename Allocator = std::allocator&lt;Elem&gt;&gt; class Container = std::vector&gt;
struct Stack
&#123;
    void push(const T&amp; elem)
    &#123;
        elems.push_back(elem);
    &#125;

    T pop()
    &#123;
        if(empty()) throw std::out_of_range(&quot;Stack&lt;&gt;::pop: empty!&quot;);

        auto elem = elems.back();
        elems.pop_back();
        return elem;
    &#125;

    bool empty() const
    &#123;
        return elems.empty();
    &#125;

private:
    Container&lt;T&gt; elems;
&#125;;
</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>to+do+or+doing</title>
    <url>/2021/12/12/to-do-or-doing/</url>
    <content><![CDATA[<p><img src="/images/todo.png"> </p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>transformer</title>
    <url>/2022/01/02/transformer/</url>
    <content><![CDATA[<p><img src="/images/transformer.png"> </p>
]]></content>
      <tags>
        <tag>transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>transition-based</title>
    <url>/2022/01/04/transition-based/</url>
    <content><![CDATA[<p><img src="/images/transition.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>transitions</title>
    <url>/2022/06/11/transitions/</url>
    <content><![CDATA[<h2 id="It’s-about-advance-transitions-in-English-writing"><a href="#It’s-about-advance-transitions-in-English-writing" class="headerlink" title="It’s about advance transitions in English writing."></a>It’s about advance transitions in English writing.</h2><p>object clause（宾语从句）</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><ul>
<li><a href="#Thereby">Thereby</a></li>
<li><a href="#Therein">Therein</a></li>
<li><a href="#Thereof">Thereof</a></li>
<li><a href="#Therefore">Therefore</a></li>
<li><a href="#Thereafter">Thereafter</a></li>
<li><a href="#Wherein">Wherein</a></li>
<li><a href="#Whereby">Whereby</a></li>
<li><a href="#Hereby">Hereby</a></li>
<li><a href="#Semicolon">Semicolon</a><br>so as to 为的是</li>
</ul>
<h2 id="Thereby"><a href="#Thereby" class="headerlink" title="Thereby:"></a>Thereby:</h2><blockquote>
<p>The team lost the final game of the season, thereby <strong>missing</strong> the playoffs<br>(thereby : through the reason)</p>
</blockquote>
<blockquote>
<p>Due to the team lost the final game of the season, they missed the palyoffs</p>
</blockquote>
<hr>
<blockquote>
<p>Lisa studied for three straight weeks and (Lisa) was <strong>thereby</strong> able to pass her test<br>(Because the reason of the last sentence and have result of the next sentence)</p>
</blockquote>
<blockquote>
<p>(Reproduce) : The ability to compound the spatial information of the CNN model exists some intractable bottlenecks and are thereby limiting the development of the AI</p>
</blockquote>
<hr>
<h2 id="Therein"><a href="#Therein" class="headerlink" title="Therein"></a>Therein</h2><p>(在其中)</p>
<blockquote>
<p>Therein lies the rub.───难就难在这里</p>
</blockquote>
<blockquote>
<p>The contract does not allow for extended maternity leave; therein lies the problem for the union, 60% of whose membership is young women<br>(合同不允许延长产假； 这就是工会的问题所在，60% 的会员是年轻女性)</p>
</blockquote>
<blockquote>
<p>The tomb, and all the contents therein(在坟墓的内容), were photographed before analysis could begin &#x3D;&#x3D; The tomb and and all the contents were photographed before analysis could begin.<br>(加therein显得更academic)</p>
</blockquote>
<p>（这里的were代表前面是多个东西，需要保持consensus,所以需要加and，这里也是两个东西，用and连接; before这个介词比较特殊，后面可以加句子，比如：Please come to my house before you leave.<br>）</p>
<h2 id="Thereof"><a href="#Thereof" class="headerlink" title="Thereof"></a>Thereof</h2><p>thereof&#x3D;of that thing mentioned earlier</p>
<blockquote>
<p>Fine wines, and a knowledge thereof (of wines) are a luxury few can afford</p>
</blockquote>
<p>（这是主语从句，一句话做主语的句子英语？<br>What he did made US surprised，这个句子就是一个主语从句做主语的例子<br>The bag i bought is too big.<br>What you see is what you get. 所见即所得。）</p>
<blockquote>
<p>We will focus on China, espeically its history and culture thereof (&#x3D;of China).</p>
</blockquote>
<blockquote>
<p>Both parties had their sights foused on the northern regions, especially the demographics thereof, and were preparing for an ad wars</p>
</blockquote>
<h2 id="Therefore"><a href="#Therefore" class="headerlink" title="Therefore"></a>Therefore</h2><p>I am well-prepared, there is no reason, therefore, that I should stumble<br>(I am well-prepared. Therefore there is no reason that I should stumble)</p>
<h2 id="Thereafter"><a href="#Thereafter" class="headerlink" title="Thereafter"></a>Thereafter</h2><p>He worked at the university until he retired; thereafter, he took on sporadic work as a consultant.</p>
<h2 id="Wherein"><a href="#Wherein" class="headerlink" title="Wherein"></a>Wherein</h2><p>Wherein(in which); wherein&#x3D;in which part</p>
<blockquote>
<p>It is not specified wherein (in which part) he violated the law.</p>
</blockquote>
<p>The affidavit did not implictly outline wherein Mr.Smith had broken any laws.</p>
<h2 id="Whereby"><a href="#Whereby" class="headerlink" title="Whereby"></a>Whereby</h2><p>whereby&#x3D; by means of which&#x2F;according to which</p>
<blockquote>
<p>a proposal whereby (according to the proposal) everyone has to learn Chinesea </p>
</blockquote>
<blockquote>
<p>a system whereby (by means of the system) you can learn Chinese everywhere</p>
</blockquote>
<blockquote>
<p>The company introduced a new incentive program whereby all employees were given an equal shot at the bonuses.</p>
</blockquote>
<h2 id="Hereby"><a href="#Hereby" class="headerlink" title="Hereby"></a>Hereby</h2><p> &#x3D; caused by this (document)</p>
<blockquote>
<p>I hereby (affected by this situation) agree&#x2F;submit…</p>
</blockquote>
<blockquote>
<p>Given the present circumstances, I hereby resign my post as CEO</p>
</blockquote>
<h2 id="Semicolon"><a href="#Semicolon" class="headerlink" title="Semicolon"></a>Semicolon</h2><blockquote>
<p>英文写作中如何使用分号(Semicolon)<br>在分隔两个独立的概念(两个独立的从句)时，我们使用分号，但前提是这两个句子是有相关性的。当陈列复杂的概念或短语，并且句中包含逗号时，适合使用分号来分隔。分号拥有逗号的功能，但包含更多意思，亦有冒号的功能，但在使用起来更加灵活。<br>在句中加入两个或多个概念，而这些概念互为平等时：</p>
</blockquote>
<p>The universe has always called to human beings; there could be no more final frontier than space.</p>
<blockquote>
<p>加入两个用连接副词或转折片语连接的独立从句：</p>
</blockquote>
<p>Sam thought David was inviting him to the picnic to enjoy a nice day out; as it turned out, David was planning a surprise birthday party.</p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>vector二维数组</title>
    <url>/2022/06/30/vector%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="vector二维数组的初始化方式"><a href="#vector二维数组的初始化方式" class="headerlink" title="vector二维数组的初始化方式"></a>vector二维数组的初始化方式</h1><ul>
<li>vector&lt;vector<char> &gt;vec(row,vector<char>(col,’#’));<blockquote>
<p>这里的row,col代表二维vector的两个轴方向的大小</p>
</blockquote>
</li>
<li>第二种通过resize确定大小，之后循环赋值</li>
</ul>
<pre><code>vector&lt;vector&lt;char&gt; &gt;vec1;
vec1.resize(row);
for(int i=0;i&lt;vec1.size();i++)
    vec1[i].resize(col);
for(int i=0;i&lt;row;i++)
    for(int j=0;j&lt;col;j++)  vec1[i][j]=&#39;#&#39;;
</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>vector用于cuda核函数中</title>
    <url>/2022/06/30/vector%E7%94%A8%E4%BA%8Ecuda%E6%A0%B8%E5%87%BD%E6%95%B0%E4%B8%AD/</url>
    <content><![CDATA[<blockquote>
<p>cuda中，是不支持在核函数中直接使用vector的。所以通常情况下是要使用动态数组将vector的数据提取，然后进行计算。</p>
</blockquote>
<blockquote>
<p>这里我们来介绍下如何将vector的数据转换为动态数组，并传入到核函数进行计算的。</p>
</blockquote>
<ul>
<li>一维</li>
</ul>
<pre><code>vector&lt;int&gt; b;
int* a;
cudaMalloc((void**)&amp; a, sizeof(int) * b.size());
cudaMemcpy(a, &amp;b[0],sizeof(int) * b.size(), cudaMemcpyHostToDevice);
</code></pre>
<ul>
<li>二维比较麻烦，因为要循环处理vector中的每一个vector（每一行）,这里用一个中间的二维数组作为承接</li>
</ul>
<pre><code>vector&lt;vector&lt;int&gt;&gt; d;
int ** a_2d = new int* [d.size()];
int * a_2d_cu;
for (int i = 0; i &lt; d.size(); i++)&#123;
    int* devPtr;
    int length = d[i].size();
    cudaMalloc((void**)&amp; devPtr, sizeof(int)*length);
    cudaMemcpy(devPtr, &amp;d[i], sizeof(int)*length, cudaMemcpyHostToDevice);
    a_2d[i] = devPtr; //先把指向cuda内存的指针存在host内存的数组中
&#125;
cudaMalloc((void**)&amp; a_2d_cu, sizeof(int*)*d.size());
cudaMemcpy(a_2d_cu, a_2d, sizeof(int*)*d.size(), cudaMemcpyHostToDevice);
</code></pre>
<h2 id="这里的cudaMalloc可以进一步使用cudaMallocPitch和cudaMemcpy2D"><a href="#这里的cudaMalloc可以进一步使用cudaMallocPitch和cudaMemcpy2D" class="headerlink" title="这里的cudaMalloc可以进一步使用cudaMallocPitch和cudaMemcpy2D"></a>这里的cudaMalloc可以进一步使用cudaMallocPitch和cudaMemcpy2D</h2><pre><code>//这是为了对齐内存，如果数据不是32的整数倍的话，二维数组用这个会比较好
size_t pitch;
cudaMallocPitch(&amp; a_2d_cu, &amp;pitch, d[0].size()*sizeof(int), d.size()));
cudaMemcpy2D(a_2d_cu, pitch, a_2d, d[0].size()*sizeof(int), d[0].size()*sizeof(int), d.size(), cudaMemcpyHostToDevice);
</code></pre>
]]></content>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>warp函数</title>
    <url>/2022/07/11/warp%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="any-sync用于一个warp之间线程的数据的交换-广播（broadcast）"><a href="#any-sync用于一个warp之间线程的数据的交换-广播（broadcast）" class="headerlink" title="__any_sync用于一个warp之间线程的数据的交换-广播（broadcast）"></a>__any_sync用于一个warp之间线程的数据的交换-广播（broadcast）</h1><h2 id="这里必须注意srcLane是束内w的编号"><a href="#这里必须注意srcLane是束内w的编号" class="headerlink" title="这里必须注意srcLane是束内w的编号"></a>这里必须注意srcLane是束内w的编号</h2><blockquote>
<p>int value &#x3D; __any_sync(mask,v,srcLane,w)<br>把srcLane的线程中变量v的值广播给其他线程，其中广播的线程由mask的二进制决定</p>
</blockquote>
<pre><code>int value = __any_sync(mask,tid,2,w);
// 这里把线程2的tid值（也是2），也就是说所有线程走到这里之后的value都是2；如果tid表示是其他含义，那么其余每个线程就是用的对应的值
输出为： `shfl:  2  2  2  2  2  2  2  2 10 10 10 10 10 10 10 10`
这里的10是因为其实他现在的tid是10，但是在束编号中，他的下标是2
</code></pre>
<p><img src="/images/2022-07-11-00-37-51.png"></p>
<blockquote>
<p>__shfl_xor_sync(FULL_MASK, tid, laneMask, WIDTH);<br>按位异或，这里可以把laneMask设置为1，就是将相邻的两个线程的tid变量的值进行交换</p>
</blockquote>
]]></content>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>whom</title>
    <url>/2022/06/15/whom/</url>
    <content><![CDATA[<h2 id="What’s-different-between-who-and-whom"><a href="#What’s-different-between-who-and-whom" class="headerlink" title="What’s different between who and whom"></a>What’s different between who and whom</h2><blockquote>
<p>Put simply, use whom—which is a pronoun(代词)—when it is the object of a sentence. If you can replace the word with “her,” “him,” or “them” for example, use “whom.” You’ll know when to use “whom” if the pronoun is used in the objective case, or action is being done to the pronoun. Take the sentence:</p>
</blockquote>
<blockquote>
<p>Whom do you believe?</p>
</blockquote>
<blockquote>
<p>The sentence may sound pretentious, even snobbish. But it is correct because “whom” is the subject of the infinitive “to,” as well as the object of the sentence as a whole.</p>
</blockquote>
<blockquote>
<p>Many people thus propose that governments need to tackle this issue by controlling the media, whom they see as responsible for inciting this violence through films and television<br>(这里的whom是做宾语)</p>
</blockquote>
<blockquote>
<p>My father is a doctor whom people trusted.</p>
</blockquote>
<blockquote>
<p>Who&#x2F;Whom are you going to invite to your party?<br>(这里you是主语)<br>你要邀请谁参加你的聚会？</p>
</blockquote>
<blockquote>
<p>Who&#x2F;Whom can we turn to in case of an emergence?</p>
</blockquote>
<p>万一出现什么情况，我们可以求助于谁？</p>
<blockquote>
<p>We have no idea who&#x2F;whom the president will choose to be the new manager.</p>
</blockquote>
<ul>
<li><p>无论是引导限制性定语从句还是非限制性定语从句，当先行词指人的时候，如果不是直接用于介词后作宾语，都可以用 who（非正式）或 whom（较正式）：</p>
</li>
<li><p>This aspect is discussed further by Crane, who &#x2F; whom I mentioned earlier. 我前面提到过的克雷恩对这方面作了进一步的论述。</p>
</li>
<li><p>In that year he met Rachel, who &#x2F; whom he was later to marry. 那年他遇到了雷切尔，后来和她结了婚。</p>
</li>
</ul>
<p>注意：直接用于介词后作宾语，只能用 whom：</p>
<ul>
<li>I met a man with whom I used to work.  我碰见了个过去曾一起工作的人。</li>
</ul>
<p>顺便说一句，引导特殊疑问句时也是如此。如：</p>
<p>Whom &#x2F; Who are you writing to? 你在给谁写信?</p>
<p>Whom &#x2F; Who do you like best? 你最喜欢谁?</p>
<p>若是紧跟在介词之后用作宾语，则只能用 whom，但这类表达通常只见于较正式的文体中。如：</p>
<p>With whom did you go? 你跟谁一起去的?</p>
<p><img src="/images/whom.png"> </p>
<h2 id="whom是作为宾语"><a href="#whom是作为宾语" class="headerlink" title="whom是作为宾语"></a>whom是作为宾语</h2><p>1.Who is at the door?</p>
<p>2.Whom did you see at the door?</p>
<p>你知道为什么第一句要用who，而第二句用whom吗?答案是，who永远在句子或从句中作为主语使用，而whom永远作为宾语。</p>
<p>在上面的第一句话中who是主语。第二局中，you才是主语，而whom是直接宾语。</p>
<p>1.whom did you recommend for the job?</p>
<p>2.Are there any people whom you would recommend?</p>
<p>注意，在上面的两句中，you是主语。whom是动词“推荐”的宾语。</p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2022/01/04/word2vec/</url>
    <content><![CDATA[<p><img src="/images/word2vec.png"> </p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>主语从句</title>
    <url>/2022/08/24/%E4%B8%BB%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="主语从句：在句子中担当主语的是一个从句，这个从句就叫做主语从句，通常放在主句谓语动词之前或由形式主语it代替，而本身放在句子末尾"><a href="#主语从句：在句子中担当主语的是一个从句，这个从句就叫做主语从句，通常放在主句谓语动词之前或由形式主语it代替，而本身放在句子末尾" class="headerlink" title="主语从句：在句子中担当主语的是一个从句，这个从句就叫做主语从句，通常放在主句谓语动词之前或由形式主语it代替，而本身放在句子末尾"></a>主语从句：<strong>在句子中担当主语的是一个从句</strong>，这个从句就叫做主语从句，通常放在主句谓语动词之前或由形式主语it代替，而本身放在句子末尾</h2><blockquote>
<p>主语从句使用陈述语序，其通常结构为“引导词 + 主语 + 谓语 + 其他成分”；</p>
</blockquote>
<ol>
<li><p>that</p>
<ul>
<li>That you are coming to London is the best news(定从，做从句宾语可以省略) I have heard this long time.<blockquote>
<p>一般来说会用形式主语it来代替主语，真正的主语放后面</p>
</blockquote>
</li>
<li>It is the best news I have heard this long time that you are coming to London</li>
</ul>
</li>
<li><p>whether引导</p>
<ul>
<li>Whether they would support us was a problem</li>
<li>However, whether such a sense of fairness evolved independently in capuchins and humans, or whether it stems from the common ancestor that the species had 35 million years ago, is, as yet, an unanswered question<ul>
<li>whether引导的两个并列主语从句做is的主语</li>
</ul>
</li>
</ul>
</li>
<li><p>连接代词引导</p>
<blockquote>
<p>例句：Whoever is top from wins the game when two matched players meet. 两强相争勇者胜。</p>
</blockquote>
</li>
<li><p>连接副词引导</p>
<blockquote>
<p>例句：How this happended is not clear to anyone. 这件事怎样发生的，谁也不清楚。</p>
</blockquote>
</li>
<li><p>关系代词型what引导</p>
<blockquote>
<p>例句：What struck me was that they have all suffered a lot. 给我很深印象的是他们都受过很多苦。</p>
</blockquote>
</li>
</ol>
<h2 id="二、主语从句与形式主语it"><a href="#二、主语从句与形式主语it" class="headerlink" title="二、主语从句与形式主语it"></a>二、主语从句与形式主语it</h2><ol>
<li>对于以连词that引导的主语从句，通常用形式主语代主语从句：</li>
</ol>
<p>例句：That they should refuse to sign the petition required great courage. 他们拒绝在请愿书上签字这是需要很大勇气的。</p>
<ol start="2">
<li>对于以连接代词(副词)引导的主语从句，可以使用形式主语代主语从句，也可直接在句首使用主语从句：</li>
</ol>
<p>例句：Whether they would support us was a problem. 他们是否会支持我们还是一个问题。</p>
<ol start="3">
<li>对关系代词型what引导的主语从句，通常直接将主语从句放在句首。</li>
</ol>
<p>例句：What I want to know is this. 我想知道的就是这一点。</p>
<p>有时也可将助用形式主语。</p>
<p>例句：It is clear enough what he meant. 他是什么意思很清楚。</p>
<ol start="4">
<li>如果句子是疑问句，则必须用带形式主语it的结构：</li>
</ol>
<p>例句：Is it true that he is the girl’s father? 他是那女孩的父亲，是真的吗?</p>
<h2 id="三、连词that的省略问题"><a href="#三、连词that的省略问题" class="headerlink" title="三、连词that的省略问题"></a>三、连词that的省略问题</h2><blockquote>
<p>引导主语从句的连词that 有时可省，有时不能省，其原则是：若that引导的主语从句直接位于句首，则that不能省略；若that引导的主语从句位于句末，而在句首使用了形式主语it，则that可以省略：</p>
</blockquote>
<pre><code>&gt; 例句：That you didn’t go to the talk was a pity. 很遗憾你没去听报告。(that不可省)

&gt; 例句：It was a pity (that) you didn’t go to the talk. 很遗憾你没去听报告。(that可省)
</code></pre>
]]></content>
      <tags>
        <tag>Enlish</tag>
      </tags>
  </entry>
  <entry>
    <title>分治法</title>
    <url>/2022/09/03/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分治法：找子解，最后结合子解，比如需要找子解的最小值或最大值作为原问题的解"><a href="#分治法：找子解，最后结合子解，比如需要找子解的最小值或最大值作为原问题的解" class="headerlink" title="分治法：找子解，最后结合子解，比如需要找子解的最小值或最大值作为原问题的解"></a>分治法：找子解，最后结合子解，比如需要找子解的最小值或最大值作为原问题的解</h1><pre><code>//
//  main.cpp
//  两个数组调整为一样的最小距离
//
//  Created by moule on 2022/9/3.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int minimal_distance(vector&lt;int&gt;&amp; num1, vector&lt;int&gt;&amp; num2, int idx1, int idx2)&#123;
    
    if(idx1 == num1.size() &amp;&amp; idx2 == num2.size())&#123;
        return 0;
    &#125;
    if(idx1==num1.size() &amp;&amp; idx2 != num2.size())&#123;
       // cout &lt;&lt; idx2 &lt;&lt; endl;
        int k = num2[idx2] + minimal_distance(num1, num2, idx1, idx2+1);
        return k;
    &#125;
    if(idx2==num2.size() &amp;&amp; idx1 != num1.size())&#123;
       // cout &lt;&lt; idx2 &lt;&lt; endl;
        return num1[idx1] + minimal_distance(num1, num2, idx1+1, idx2);
        
    &#125;
    // delete num1[idx1]
    
    int p1 = num1[idx1] + minimal_distance(num1, num2, idx1+1, idx2);
 //   cout &lt;&lt; p1;
    // delete num2[idx2]
    int p2 = num2[idx2] + minimal_distance(num1, num2, idx1, idx2+1);
   // cout &lt;&lt; p2;
//    // num1[idx1] - num2[idx2]
    int p3 = abs(num1[idx1]-num2[idx2]) + minimal_distance(num1, num2, idx1+1, idx2+1);
   
    
    return min((p1,p2),p3);
&#125;
int main(int argc, const char * argv[]) &#123;
    // insert code here...
    vector&lt;int&gt; num1 = &#123;2,3&#125;;
    vector&lt;int&gt; num2 = &#123;2,3,5&#125;;
    cout &lt;&lt; minimal_distance(num1, num2, 0, 0) &lt;&lt; endl;
    std::cout &lt;&lt; &quot;Hello, World!\n&quot;;
    return 0;
&#125;
</code></pre>
<h2 id="比如汉诺塔问题，汉诺塔问题就是子问题，不需要结合子解，全部的子解就是整个问题的解"><a href="#比如汉诺塔问题，汉诺塔问题就是子问题，不需要结合子解，全部的子解就是整个问题的解" class="headerlink" title="比如汉诺塔问题，汉诺塔问题就是子问题，不需要结合子解，全部的子解就是整个问题的解"></a>比如汉诺塔问题，汉诺塔问题就是子问题，不需要结合子解，全部的子解就是整个问题的解</h2><p><img src="/images/2022-09-03-21-56-00.png"><br><img src="/images/2022-09-03-21-56-18.png"><br><img src="/images/2022-09-03-21-56-31.png"></p>
<blockquote>
<p>汉诺塔的子问题如下：</p>
</blockquote>
<pre><code>- 1）把 N-1个盘子 移到中转柱
- 2）把第N个盘子移动到 目标柱
- 3）把中转柱上面的N-1个盘子借助目前空闲的柱子 移动到 目标柱。
</code></pre>
<blockquote>
<p>两个数组变为一样的子问题</p>
</blockquote>
<pre><code>- 1）第一个数组的下标数删掉
- 2）第二个数组的下标数删掉
- 3）删掉两个数组对应下标数值的差
合：找到三个子解代价最小的
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>原反补码</title>
    <url>/2022/06/26/%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p><img src="/images/coding.png"></p>
]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>均方误差分解</title>
    <url>/2022/05/21/%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/images/biasAndvariance.png"> </p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐</title>
    <url>/2022/08/25/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<ul>
<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li>
<li>结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal padding）；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）</li>
</ul>
<p>比如</p>
<pre><code>struct student
&#123;
    char name[5];
    int num;
    short score;
&#125;
</code></pre>
<p>|char|char|char|char|<br>|char|—-|—-|—-|<br>|——–int——–|<br>|–short–|—-|—-|</p>
<p>本来只用了11bytes（5+4+2）的空间，但是由于int型默认4字节对齐，存放在地址能被4整除的起始位置，即：如果name[5]从0开始存放，它占5bytes，而num则从第8(<strong>因为int是4，开始存的位置必须要可以整除4</strong>)（偏移量）个字节开始存放。所以sizeof(student)&#x3D;16。于是中间空出几个字节闲置着。但这样便于计算机快速读写数据，是一种以空间换取时间的方式。其数据对齐如下图：</p>
<pre><code>struct student
&#123;
    int num;
    char name[5];
    short score;
&#125;
</code></pre>
<p>num从0开始存放，而name从第4（偏移量）个字节开始存放，连续5个字节，score从第10（偏移量）开始存放，故sizeof(student)&#x3D;12。其数据对齐如下图：<br>|——–int——–|<br>|char|char|char|char|<br>|char|—-|–short–|</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>定语从句省略</title>
    <url>/2022/08/21/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5%E7%9C%81%E7%95%A5/</url>
    <content><![CDATA[<ul>
<li><p><a href="#%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5">定从that省略</a></p>
</li>
<li><p><a href="#%E6%B3%A8%E6%84%8F%E8%BF%99%E4%B8%AA%E5%8E%9F%E5%88%99%E5%90%8C%E6%A0%B7%E9%80%82%E7%94%A8%E4%BA%8E%E5%85%B3%E7%B3%BB%E8%AF%8D%E4%B8%BA-who-%E5%92%8C-which%E7%9A%84%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5">定从who和which省略</a></p>
</li>
<li><p><a href="#%E5%88%A4%E6%96%AD">判断</a></p>
</li>
</ul>
<h1 id="定语从句什么时候可以省略"><a href="#定语从句什么时候可以省略" class="headerlink" title="定语从句什么时候可以省略"></a>定语从句什么时候可以省略</h1><ul>
<li>定语从句本质上是一个<strong>形容词</strong>，修饰名词。从句子的树形结构出发，任何定语从句可以被拆分成两个句子。</li>
</ul>
<blockquote>
<p>eg: The cat that is eating an apple has a cute head.<br>这里拆分<br><img src="/images/2022-08-21-15-06-03.png"></p>
</blockquote>
<p><strong>注意看，这里的that扮演的是从句的主语部分</strong></p>
<blockquote>
<p>eg:  The cat that I bought has a cute head.<br>这里拆分<br><img src="/images/2022-08-21-15-06-59.png"></p>
</blockquote>
<p><strong>注意看，这里的that是从句的宾语部分，这里的that可以省略</strong></p>
<h2 id="summary："><a href="#summary：" class="headerlink" title="summary："></a>summary：</h2><h3 id="当that只有在从句中扮演宾语时，这个that就可以省略，否则不可省略"><a href="#当that只有在从句中扮演宾语时，这个that就可以省略，否则不可省略" class="headerlink" title="当that只有在从句中扮演宾语时，这个that就可以省略，否则不可省略"></a>当that只有在从句中扮演宾语时，这个that就可以省略，否则不可省略</h3><blockquote>
<p>The cat that is eating an apple has a cute head.<br>The cat I bought has a cute head.</p>
</blockquote>
<h1 id="注意，这个原则同样适用于关系词为-who-和-which的定语从句。"><a href="#注意，这个原则同样适用于关系词为-who-和-which的定语从句。" class="headerlink" title="注意，这个原则同样适用于关系词为 who 和 which的定语从句。"></a>注意，这个原则同样适用于关系词为 who 和 which的定语从句。</h1><blockquote>
<p>eg: The man who once saved my life is speaking.<br>eg: The man whom you saw on the street once saved my life.</p>
</blockquote>
<p>这里的who可以换成whom，因为做宾语，更进一步，这里的whom可以省略，因为这个是定语从句，whom做的宾语</p>
<blockquote>
<p>eg: The man you saw on the street once saved my life.</p>
</blockquote>
<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>如果关系代词（that、which、who）后面直接跟的是动词，则关系代词做主语，即不可省略。如果不是动词，那么可以直接省略。</p>
<blockquote>
<p>eg：The picture which caused the sensation is on exhibition.</p>
</blockquote>
<p>(which 后面紧跟动词 caused，在从句中作主语，不可省略)</p>
<blockquote>
<p>eg：The picture that I drew last year is on exhibition.<br>(that 后面紧跟的不是动词，因此可以省略 that)</p>
</blockquote>
<h2 id="定语从句和名词性从句的区别"><a href="#定语从句和名词性从句的区别" class="headerlink" title="定语从句和名词性从句的区别"></a>定语从句和名词性从句的区别</h2><blockquote>
<p>名词性从句(Noun clause)是在句子中起<strong>名词</strong>作用的句子。 名词性从句的功能相当于名词词组， 它在复合句中能担任主语、宾语、表语、同位语、介词宾语等，因此根据它在句中不同的语法功能，名词性从句又可分别称为<strong>主语从句、宾语从句、表语从句和同位语从句</strong>。</p>
</blockquote>
<ol>
<li><p>第一，定语从句有先行词，且先行词可以放入后面的从句中使从句完整；</p>
</li>
<li><p>第二，名词从句的功能相当于名词词组，在复合句中可担任主语、宾语、同位语等，在句中有不同的语法功能；</p>
</li>
<li><p>第三，名词从句相当于名词，而定语从句相当于形容词，修饰或限定名词和代词；</p>
</li>
<li><p>第四，定语从句在句中只做定语，即使去掉句子也还完整，而名词性从句充当句子的骨干成分，不可去掉。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>宾语从句</title>
    <url>/2022/08/21/%E5%AE%BE%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="宾语从句（objective-clause）"><a href="#宾语从句（objective-clause）" class="headerlink" title="宾语从句（objective clause）"></a>宾语从句（objective clause）</h1><p>that引导的宾语从句作动词或某些形容词的宾语时，that在口语和非正式文体中可以省略，并且是经常省略。<br><img src="/images/2022-08-21-17-29-44.png"></p>
<h2 id="下面这些情况下that是不能省略的"><a href="#下面这些情况下that是不能省略的" class="headerlink" title="下面这些情况下that是不能省略的"></a>下面这些情况下that是不能省略的</h2><ol>
<li><p>that引导的宾语从句作动词的宾语时，如果动词的后面有几个并列that引导的宾语从句，这时只有紧挨着动词的第一个that可以省略，其他的that都不可以省略。比如：<br><img src="/images/2022-08-21-17-30-29.png"></p>
</li>
<li><p>当为了强调把that引导的宾语从句可位于句首时，that不能省略。如：</p>
<ul>
<li><blockquote>
<p>That she is a good girl I know. 她是一个好姑娘，我是知道的。</p>
</blockquote>
</li>
<li><blockquote>
<p>That he ever said such a thing I simply don’t believe. 我简直不相信他曾说过这样的话。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当that从句与动词被其他词或从句隔开时，that一般不宜省略，以免造成语义混乱。如：</p>
<ul>
<li><blockquote>
<p>They told us once again that the situation was serious.他们又一次告诉我们说形势是严重的。</p>
</blockquote>
</li>
<li><blockquote>
<p>The dealer told me how much he was prepared to pay for my car and that I could have the money without delay. 那个商人告诉我他准备出多少钱买我的汽车，并说我会立即收到款。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>动词后面如果接的是复合宾语，即宾语+宾补的结构，宾语是一个由that引导的宾语从句，这时候要用it做形式宾语来替代宾语从句，而把这个宾语从句放在句子后面，这时候that不能省略。比如：<br><img src="/images/2022-08-21-17-38-41.png"></p>
</li>
<li><p>that引导的宾语从句作一些介词的宾语，这些介词有：except、but、 in，that不能省略。这里需要知道的是除了这几个介词，that引导的宾语从句一般不作介词的宾语。比如：<br><img src="/images/2022-08-21-17-39-00.png"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>宾语补足语</title>
    <url>/2022/08/22/%E5%AE%BE%E8%AF%AD%E8%A1%A5%E8%B6%B3%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="有时候动词后面会跟着多个名词或其他词，尤其是动-名-名不太好理解，这里就是宾语补足语"><a href="#有时候动词后面会跟着多个名词或其他词，尤其是动-名-名不太好理解，这里就是宾语补足语" class="headerlink" title="有时候动词后面会跟着多个名词或其他词，尤其是动+名+名不太好理解，这里就是宾语补足语"></a>有时候动词后面会跟着多个名词或其他词，尤其是动+名+名不太好理解，这里就是宾语补足语</h1><ul>
<li>本质上来说后面的名词也是修饰前面的名词的<ul>
<li>名词做宾补<blockquote>
<p>eg: I think the job a great honor. 我认为这份工作是一份荣誉</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>按位与替换取余操作</title>
    <url>/2022/07/06/%E6%8C%89%E4%BD%8D%E4%B8%8E%E6%9B%BF%E6%8D%A2%E5%8F%96%E4%BD%99%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>由于我们知道位运算比较高效，在某些情况下，当b为2的n次方时，有如下替换公式：</p>
</blockquote>
<blockquote>
<p><code>a % b = a &amp; (b-1)</code></p>
</blockquote>
<h2 id="notes"><a href="#notes" class="headerlink" title="notes:"></a>notes:</h2><ul>
<li>b必须为2的整数倍<blockquote>
<p>因为可以保证b始终只有最高位为1，其他二进制位全部为0，减去1，之后，可以把高位1消除，其他位都为1。<br><code>减一之后，最高位为0，之后都为1（b,b剩下的数就是需要的余数的最高值），就相当于计算低位与原数的与</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>例如：14%8，取余数，相当于取出低位，而余数最大为7，14二进制为1110，8的二进制1000，8-1 &#x3D; 7的二进制为0111，由于现在低位全为1，让其跟14做&amp;运算，正好取出的是其低位上的余数 </p>
</blockquote>
]]></content>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>期望和方差</title>
    <url>/2022/05/21/%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE/</url>
    <content><![CDATA[<p><img src="/images/expectAndvariance.png"> </p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>模版内的友元</title>
    <url>/2022/06/18/%E6%A8%A1%E7%89%88%E5%86%85%E7%9A%84%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<h1 id="模板类使用友元模板函数"><a href="#模板类使用友元模板函数" class="headerlink" title="模板类使用友元模板函数"></a>模板类使用友元模板函数</h1><p>在类模板中可以出现三种友元声明：<br>（1）普通非模板类或函数的友元声明，将友元关系授予明确指定的类或函数。<br>（2）类模板或函数模板的友元声明，授予对友元所有实例的访问权。<br>（3）只授予对类模板或函数模板的特定实例的访问权的友元声明。</p>
<p>（1）普通友元：</p>
<pre><code>template&lt;class T&gt;

class A&#123;

   friend void fun();

//...

&#125;;
此例中fun可访问A任意类实例中的私有和保护成员
</code></pre>
<p>（2）一般模板友元关系</p>
<pre><code>template&lt;class type&gt;

class A&#123;

  template&lt;classT&gt;

   friend void fun(T u);

//...

&#125;;

这时友元使用与类不同的模板形参，T可以是任意合法标志符，友元函数可以访问A类的任何类实例的数据，即不论A的形参是int，double或其他都可以。
</code></pre>
<p>（3）特定的模板友元关系</p>
<pre><code>template &lt;class T&gt; void fun(T,u);//对与特定的模板友元关系，这里的声明是必须的

template&lt;class T&gt;

class A&#123;

   friend voidfun&lt;T&gt;(T u);//这里也可以是friend void fun&lt;char&gt;(char u);

//...

&#125;;

此时fun只有访问类中特定实例的数据。换句话说，此时具有相同模板实参的fun函数与A类才是友元关系。即假如调用fun时其模板实参为int，则它只具有A&lt;int&gt;的访问权限。当然friendvoid fun&lt;T&gt;(Tu);中&lt;&gt;中的T可以是任意类型，比如int，double等

 

 

 

对类建立友元函数很容易。但是迁移到模板上却容易出现让人摸不着头脑的连接错误。
层次不够，不做分析，单纯介绍两种为类模板定义友元函数的方法
</code></pre>
<pre><code>　　１　封闭型

template&lt; typename T &gt;
class MyClass
&#123;
    friend void function( MyClass&lt; T &gt; &amp;arg )
    &#123;
        
     &#125;
 &#125;;　　要点：友元函数定义在模板体内。

       ２　开放型
template&lt; typename T &gt;
class MyClass
&#123;
    template&lt; typename C &gt;
    friend void function( MyClass&lt; C &gt; &amp;arg );
 &#125;;

template&lt; typename C &gt;
void function( MyClass&lt; C &gt; &amp;arg )
&#123;
    
 &#125;　　要点：模板体内要另建模板。 
　　
　　3 告诉编译器声明的设个是模板
#include &lt;iostream&gt;
using namespace std;

template &lt; typename T &gt;
class A
&#123;
    friend ostream &amp;operator&lt;&lt; &lt; T &gt;( ostream &amp;, const A&lt; T &gt; &amp; );
 &#125;;

template &lt; typename T &gt;
ostream &amp;operator&lt;&lt; ( ostream &amp;output, const A&lt; T &gt; &amp;a )
&#123;
    output &lt;&lt; &quot;重载成功&quot; &lt;&lt; endl;
    return output;
 &#125;

int main()
&#123;
    A&lt; int &gt; a;
    cout &lt;&lt; a;
 &#125;要点：显示地在重载的运算符或者函数后面加上模板声明&lt; T&gt;，告诉编译器友元函数是一个类型一致的模板。
</code></pre>
<p> 建议：<br>            如果希望使用函数与模板特化的类型相对应，则使用方法3（模板显示声明）<br>            如果希望使用函数与模板特化的类型相独立，则使用方法2（二重模板）<br>            简短的内联函数使用方法1</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>状语从句</title>
    <url>/2022/08/20/%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="状语从句主谓成分的省略，须遵循下面原则："><a href="#状语从句主谓成分的省略，须遵循下面原则：" class="headerlink" title="状语从句主谓成分的省略，须遵循下面原则："></a>状语从句主谓成分的省略，须遵循下面原则：</h1><ol>
<li><p>当从句的主语与主句的主语一致时，从句可以省略主语，从句的谓语动词采用其V-ing结构。例如：</p>
<ul>
<li><p>Although working very hard, he failed in the final exam. (Although he worked very hard）</p>
</li>
<li><p>After taking the medicine, she felt much better. (After she took the medicine)</p>
</li>
<li><p>If going there by air, we’ll have to pay twice the fare. (If we go there by air)</p>
</li>
</ul>
</li>
<li><p>当从句的主语和主句的主语一致时，若从句的谓语动词是系动词be或包含be的某种形式，此时从句的主语和be动词通常可以一同省略</p>
<ul>
<li>Whenever (she is) free, she often goes shopping.她有空就去逛商店。</li>
<li>Work hard when (you are) young, or you’ll regret.少壮不努力,老大徒伤悲。</li>
<li>While (he was) a young boy, he was always ready to help others. 他在孩提时代就乐于助人。<br> <img src="/images/2022-08-22-11-59-37.png"><br> <img src="/images/2022-08-22-11-59-56.png"></li>
</ul>
</li>
<li><p>若从句的主语和主句的主语不一致，但和主句的宾语一致时，从句中的主语和be动词亦常可省略。例如：</p>
<ul>
<li>Father advised me not to say anything until (I was) asked.</li>
</ul>
</li>
<li><p>当从句的主语是it, 且谓语动词是be或包含be的某种形式时, it和be常可同时省略。例如:</p>
<ul>
<li><p>If (it is) possible, he will help you out of the difficulty.如果可能的话,他会帮你摆脱困境。</p>
</li>
<li><p>You must attend the meeting unless (it is) inconvenient to you.除非情况对你来说不方便,否则你必须出席这次会议。</p>
</li>
</ul>
</li>
</ol>
<p><img src="/images/2022-08-22-12-05-52.png"></p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>类内声明和定义</title>
    <url>/2022/03/10/%E7%B1%BB%E5%86%85%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>1.类内定义</p>
<pre><code>    类内定义的概念：成员函数的函数体（实现）是在类的内部完成的。这种实现方式c++隐式为内联函数。

   A.h
</code></pre>
<p>class A<br>{<br>public:<br>    A(void);<br>    virtual ~A(void);<br>    int test(){return 1;};<br>    int test1();<br>};<br>         可以看到类A中成员函数test()的定义在类的内部，隐式为内联函数（inline的原理，是用空间换取时间的做法，是以代码复制为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。所以，如果函数体代码过长或者函数体重有循环语句，if语句或switch语句或递归时，不宜用内联）。</p>
<p>2.类外定义</p>
<pre><code>   类外定义的概念:成员函数的定义是在类的外部实现的就像类A中的成员函数test1()，在类中只有声明。

   A.h
</code></pre>
<p>class A<br>{<br>public:<br>    A(void);<br>    virtual ~A(void);<br>    int test(){return 1;};<br>    int test1();<br>};<br>      A.cpp</p>
<p>#include “A.h”</p>
<p>A::A(void)<br>{<br>}<br>A::~A(void)<br>{<br>}<br>int A::test1()<br>{<br>    return 1;<br>}<br>     这种类外定义的方式属于分文件类外定义，声明和定义不在同一文件中，还有一种类外定义方式为同文件类外定义，声明和定义在同一个.cpp文件中。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2022/06/28/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="红黑树五大特性"><a href="#红黑树五大特性" class="headerlink" title="红黑树五大特性"></a>红黑树五大特性</h1><ul>
<li>节点是红&#x2F;黑</li>
<li>根结点是黑</li>
<li>空叶子是黑色的（叶子结点和度为一的结点：度为0和度为1）</li>
<li>红色结点的孩子肯定是黑色的（从根到空叶子的简单路径不存在连续红色结点）</li>
<li>从根出发到所有空叶子结点的简单路径当中<code>黑色</code>结点数量相同</li>
</ul>
<blockquote>
<p>因此，全黑的一条路径最短，并且 <code>最长&lt; 2*最短</code></p>
</blockquote>
<h1 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h1><ul>
<li>1 初始插入时红色的，先用二叉搜索树的朴素插入构建红黑树</li>
<li>2 插完之后染色并旋转</li>
</ul>
<h2 id="建树不同情况-（插入为红）"><a href="#建树不同情况-（插入为红）" class="headerlink" title="建树不同情况 （插入为红）"></a>建树不同情况 （插入为红）</h2><ul>
<li>1 加入插入的是根，直接染黑</li>
<li>2 插入是子，如果父亲是黑色，不需要做任何调整</li>
<li>3 插入是子，父亲是红色（一定有爷爷结点，且是黑色，因为父亲是红色)，也一定有叔叔结点（空叶子也算），叔叔如果是红色，<code>父亲和叔叔染黑</code>, <code>爷爷染红</code>-&gt;染红会出现问题，因此把爷爷看作新插入的结点，循环向上插入</li>
<li>4 插入是子，父亲是红色（一定有爷爷结点)，也一定有叔叔结点（空叶子也算），叔叔如果是黑色，<br>如果父亲P的大小在新插入的N和爷爷G之间（插入的位置和父亲一样，比如父亲是左子树，插入的也是左子树；父亲是右子树，插入的也是右子树），则对G旋转，左边重(插入子左子树)，<code>就右旋</code>，右边重（插入在右子树），<code>就左旋</code> （裙子形），并互换颜色，<code>G和P颜色互换</code><blockquote>
<p>右旋：把爷爷作为父亲的右孩子结点<br>左旋：把爷爷作为父亲的左孩子结点</p>
</blockquote>
</li>
<li>5 插入有子，父亲是红色（一定有爷爷结点)，也一定有叔叔结点（空叶子也算），叔叔如果是黑色，但是新插入的N和父亲的位置相反。旋转P，之前是旋转G。如果父亲是左子树，则左旋P；如果父亲是右子树，则右旋P，现在回到情况4，使用情况4的方法就行；父亲在右边，N在左边，以父节点进行右旋，这是父亲和N都在右边，在进行上述情况4同右操作即可</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>插入节点为根节点，变为黑色</li>
<li>父节点为黑色，直接插入</li>
<li>父节点和叔叔节点均为红色，父节点和叔叔节点均变为黑色，祖父节点变红，把祖父节点当作要插入节点，递归执行。</li>
<li>父节点和插入节点在同一边，父节点变黑，祖父节点变红，同左右旋，同右左旋。这里是对祖父结点进行的</li>
<li>父节点为红色，叔叔节点为黑色，如果不在同一边，转换为同一边（N在右边以父节点左旋；N在左边，以父节点右旋），然后执行步骤四。</li>
</ul>
<p><img src="/images/red-black-tree.png"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性插值</title>
    <url>/2022/08/20/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<p><img src="/images/2022-08-28-19-14-47.png"></p>
]]></content>
      <tags>
        <tag>ShiftGCN</tag>
      </tags>
  </entry>
  <entry>
    <title>英语句子</title>
    <url>/2021/12/22/%E8%8B%B1%E8%AF%AD%E5%8F%A5%E5%AD%90/</url>
    <content><![CDATA[<blockquote>
<p>commence—Many people have wondered why the end of someone’s school days should be celebrated by Commencement Exercises, which, ordinarily, refer to a beginning</p>
</blockquote>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>过去式</title>
    <url>/2021/12/25/%E8%BF%87%E5%8E%BB%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="过去式变化规则"><a href="#过去式变化规则" class="headerlink" title="过去式变化规则"></a>过去式变化规则</h1><p>1）动词过去式变化规则分为规则变化和不规则变化两种，一般情况下，动词原形词尾加-ed，以不发音的-e结尾动词，动词词尾加-d，以辅音字母+y结尾的动词，把-y变为-i 再加-ed<br>2）以一个元音+一个辅音字母结尾的重读闭音节动词，双写词尾辅音字母，否则就加ed<br>preFER-&gt;preFERRed<br>VISit-&gt;VISited<br>3）不满足一个元音+一个辅音结尾 + ed<br>start-&gt;started 两个辅音结尾<br>need-&gt;needed<br>3) 一个元音+y +ed<br>stay-&gt;stayed</p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>过拟合和欠拟合</title>
    <url>/2022/05/22/%E8%BF%87%E6%8B%9F%E5%90%88%E5%92%8C%E6%AC%A0%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<p><img src="/images/overfit.png"> </p>
]]></content>
      <tags>
        <tag>machine</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2022/03/12/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>做个简单的比喻：进程&#x3D;火车，线程&#x3D;车厢线程在进程下行进（<br>单纯的车厢无法运行）一个进程可以包含多个线程（一辆火车可以有多个车厢）<br>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）<br>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）<br>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）<br>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）<br>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）<br>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>递归回溯</title>
    <url>/2022/08/17/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="当有多重递归的时候，人脑无法模拟出递归过程，因此需要借助递归树"><a href="#当有多重递归的时候，人脑无法模拟出递归过程，因此需要借助递归树" class="headerlink" title="当有多重递归的时候，人脑无法模拟出递归过程，因此需要借助递归树"></a>当有多重递归的时候，人脑无法模拟出递归过程，因此需要借助<strong>递归树</strong></h1><p><img src="/images/2022-08-17-15-00-21.png"></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
void recursion(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; temp,int target, int sum,int count,int&amp; len,int current)&#123;
    //递归三部曲
    //- 确定参数和返回值
    //- 确定终止条件
    //- 单层递归逻辑
    
    if(sum&gt;=target)&#123;
        //这里只有递归的时候才会调用
        len = min(len, count);
        return;
    &#125;
    for(int i=current;i&lt;nums.size();i++)&#123;
        //原本是4，先回溯到4，for循环结束
        //开始第二个回溯，i=3(这个时候sum和count还有temp都减掉了i=3和i=4的情况)，经过for之后i=4
        // 然后sum加上了i=4的情况，忽略i=3
        //之后再回溯到i=2,经过for之后i=3(这里又开始叠加两层递归（i=3和i=4），
        //并且对于i=3来说，i=2的值是没有的因为被回溯来，对于i=4来说，这个是i=3的孩子结点)
        //通过递归树来分析所有的递归流程
        count++;
        sum += nums[i];
        temp.push_back(nums[i]);
        recursion(nums, temp,target,sum,count,len,i+1);
        //这里开始回溯，sum和count还有temp都回溯了，但是注意i没有
        sum -= nums[i];
        temp.pop_back();
        count--;    
    &#125;
&#125;
int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;  
    int len=999;
    vector&lt;int&gt; temp;
    recursion(nums,temp,s,0,0,len,0);
    if (len==999)
        return 0;
    return len;
&#125;
int main(int argc, const char * argv[]) &#123;
    // insert code here...
    vector&lt;int&gt; nums=&#123;1,2,3,4,5&#125;;
    int len = minSubArrayLen(15,nums);
    cout &lt;&lt; len&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<h2 id="以下这些都可以用递归回溯来解决"><a href="#以下这些都可以用递归回溯来解决" class="headerlink" title="以下这些都可以用递归回溯来解决"></a>以下这些都可以用递归回溯来解决</h2><ul>
<li>组合问题</li>
<li>子集问题</li>
<li>分割问题</li>
<li>排列组合问题</li>
<li>棋盘问题<br><img src="/images/2022-08-17-15-13-18.png"></li>
</ul>
<h2 id="遇到这些问题记得先画递归树"><a href="#遇到这些问题记得先画递归树" class="headerlink" title="遇到这些问题记得先画递归树"></a>遇到这些问题记得先画递归树</h2>]]></content>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>重载new()</title>
    <url>/2022/06/21/%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="可以重载new，同时也可以重载new"><a href="#可以重载new，同时也可以重载new" class="headerlink" title="可以重载new，同时也可以重载new()"></a>可以重载new，同时也可以重载new()</h2><p>Foo* p &#x3D; new(300,”a”) Foo;</p>
<blockquote>
<p>new()里面的参数就是可以加在重载函数的参数中的<br>注意第一个参数必须是size_t</p>
</blockquote>
<pre><code>void* operator new(size_t size, int a, char c)&#123;
.....
&#125;
</code></pre>
<blockquote>
<p>这样就可以写错多个版本的new重载</p>
</blockquote>
<h2 id="delete-也可以这样写多个版本，对应new-参数版本。"><a href="#delete-也可以这样写多个版本，对应new-参数版本。" class="headerlink" title="delete()也可以这样写多个版本，对应new()参数版本。"></a>delete()也可以这样写多个版本，对应new()参数版本。</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>长难句</title>
    <url>/2022/08/20/%E9%95%BF%E9%9A%BE%E5%8F%A5/</url>
    <content><![CDATA[<ul>
<li><a href="#Despite">Despite a spell…</a></li>
<li><a href="#Social">Social science…</a></li>
<li><a href="#Railroads">Railroads…</a></li>
<li><a href="#shortlists">Shortlists…</a></li>
<li><a href="#the-emphasis">The emphasis…</a></li>
<li><a href="#whether">whether…</a></li>
<li><a href="#Stocks">Stocks…</a></li>
</ul>
<h2 id="Despite"><a href="#Despite" class="headerlink" title="Despite"></a>Despite</h2><blockquote>
<p>当状语从句的主语和主句的主语一致时,从句可以将主语和be动词简化掉（只能从句动词是be才可以）</p>
</blockquote>
<blockquote>
<p>Despite a spell of initial optimism in the 1960s and 1970s when it appeared that transistor circuits and microprocessors might be able to copy the action of human brain by the year 2010, researchers lately have begun to extend that forecast by decades if (researchers are) not centuries </p>
</blockquote>
<ul>
<li>Despite 是引导一个状语状语，对应的是have begun</li>
<li>if 是一个条件状语从句，主语和be动词省略了</li>
</ul>
<pre><code>transistor 晶体管
circuit n. 电路，v.巡回
microprocessor 处理器
by decades 几十年
</code></pre>
<hr>
<h2 id="Social"><a href="#Social" class="headerlink" title="Social"></a>Social</h2><blockquote>
<p>Social science is that branch of intellectual enquiry, which(先行词是branch of intellectual enquiry) seeks to study humans and their endeavors <strong>in（方式状语）</strong> the same reasoned, orderly, systematic, and dispassioned <strong>manner</strong> that natural scientists use（缺了宾语，这里的宾语是前面的说的manner） for the study of natural phenomena</p>
</blockquote>
<ul>
<li>in…manner 用…方式（方式状语）</li>
<li>use 是及物动词， 要加宾语，什么是宾语，宾语是动作的承受者，什么词语能够做宾语呢？一般名词，代词宾格，数词，动词不定式，动名词，句子和其他都可以做宾语。<strong>但是 谓语动词，形容词，介词，副词是一定不能做宾语的</strong></li>
</ul>
<hr>
<pre><code>curb n,v 抑制
</code></pre>
<blockquote>
<p>Curbs（名词，主语） on business-method claims（申请）（介词短语表示补充说明） would be a dramatic about-face(彻底转变), because <strong>it was</strong> the Federal Circuit itself <strong>that</strong> introduced such patents with its 1998 decision in the so-called State Street Bank case, approving（逗号加doing,这是非谓语动词修饰整个句子，看主语，主语是Federal Circuit，看和主语的关系。Federal Circuit主动赞同了一个专利在这个方面（筹集pooling是名词动词意化）筹集相互基金资产方面） a patent on a way of pooling mutual-fund assets</p>
</blockquote>
<ul>
<li>It is&#x2F;was … that 强调句，普通句子把要强调的部分放入中间，就构成强调句，删除掉it is&#x2F;was … that 也是一个完整的句子</li>
</ul>
<hr>
<ul>
<li>非谓语动词是修饰作用，一般就近修饰</li>
</ul>
<blockquote>
<p>The Federal Circuit issued an unusual order stating(非谓语doing，就近修饰order，而state这里是动词，因此后面的that是宾语从句) that the case would be heard by all 12 court’s judges, rather than a typical panel of three(这里的插入语补充说明前面的句子，造成了两个并列的宾语从句的分裂（分裂结构）), and（这里和前面的that并列，因此这里也是state所陈述的内容） that one issue it <strong>wants</strong> to evaluate（这里是主主谓谓it <strong>wants</strong> to evaluate是从句，是定语从句，这里的that可以省略，因为这个that做的是宾语，不做主语就可以省略） <strong>is</strong> whether it <strong>should</strong> “reconsider” its State Street Bank ruling.</p>
</blockquote>
<hr>
<ul>
<li>in the grips of sth 控制在…手中</li>
<li>hostility 敌意 hostile 怀有敌意的</li>
<li>hospitality 殷情 hospitable 好客的</li>
<li>militant a 好战的<br><img src="/images/2022-08-21-17-07-50.png"></li>
<li>promise 可以做潜力，希望的意思</li>
</ul>
<hr>
<h2 id="Railroads"><a href="#Railroads" class="headerlink" title="Railroads"></a>Railroads</h2><blockquote>
<p>Railroads justify（证明…合理） rate（比率，也可以做价格的意思） discrimination against(against sb 反对某人，这里是针对某人) captive shippers（受限托运商） on the grounds（以…根据） that(同位语从句) in the long run（长期看来） it reduces everyone’s cost</p>
</blockquote>
<pre><code>- against 这里做 **针对**
- rate 价格
- on the grounds 基于...  以...为根据
</code></pre>
<p><img src="/images/2022-08-22-11-31-42.png"></p>
<hr>
<h2 id="Shielded"><a href="#Shielded" class="headerlink" title="Shielded"></a>Shielded</h2><blockquote>
<p>Shielded by third-party payers(付款人) from the cost of our care, we demand everything that can possibly be done for us, even if it’s useless</p>
</blockquote>
<pre><code>- Shielded...from 保护...
- Shielded...off 避开，挡开...
</code></pre>
<p><img src="/images/2022-08-22-13-26-20.png"></p>
<hr>
<p><img src="/images/2022-08-22-14-20-12.png"></p>
<ul>
<li>while状语从句，主语一致，从句的动词可以直接用ing形式</li>
</ul>
<hr>
<h2 id="The-emphasis"><a href="#The-emphasis" class="headerlink" title="The emphasis"></a>The emphasis</h2><blockquote>
<p>The emphasis（on是介词短语做后置定语） on data gathered(非谓语做后置定语，这里是修饰data的,被收集的) first hand, combined(伴随状语) with a cross-cultural perspective brought(非谓语做后置定语，修饰perspective，被带来的) to the analysis of cultures past and persent, makes(真正的动词) <strong>this study</strong>（宾语） a unique and distinctly important social science （宾补）.</p>
</blockquote>
<ul>
<li>动词后面多个名词是可以的，是宾补，修饰前面的宾语<br><img src="/images/2022-08-22-14-59-01.png"></li>
</ul>
<hr>
<h2 id="Shortlists"><a href="#Shortlists" class="headerlink" title="Shortlists"></a>Shortlists</h2><p>Shortlists for job interviews, election ballot papers, lists of conference speakers and attendees: all tend to be drawn up alphabetically, and（并列两个简单句） their recipients lose interest as they plough through them</p>
<pre><code>- Shortlists n 入围名单， v 把什么列入名单
- ballot n 选举 v 投票
- draw up 起草
- alphabetically 按字母顺序的
- plough through 费劲地阅读
</code></pre>
<p>: 一般是解释说明前面，和all是相同的，同位语<br><img src="/images/2022-08-23-12-16-35.png"></p>
<hr>
<ul>
<li><p>come to 逐渐…</p>
</li>
<li><p>determinism 决定论<br><img src="/images/2022-08-24-19-19-01.png"></p>
</li>
</ul>
<hr>
<h2 id="whether"><a href="#whether" class="headerlink" title="whether"></a>whether</h2><p>主语从句做主语</p>
<blockquote>
<p>However, whether such a sense of fairness evolved independently in capuchins and humans, or whether it stems from the common ancestor that the species had 35 million years ago, is, as yet, an unanswered question<br>        - whether引导的两个并列主语从句做is的主语<br>eg: What she said is </p>
</blockquote>
<p><img src="/images/2022-08-24-21-24-32.png"></p>
<hr>
<p><img src="/images/2022-08-26-01-31-03.png"></p>
<ul>
<li>不定式后面也可以是宾语从句</li>
<li>suggest 启发</li>
<li>work through 逐渐…克服…<br>They are working through the negative feelings generated during the day.</li>
</ul>
<hr>
<blockquote>
<p>And one leading authority says that these intensely powerful mental events can be not only <strong>harnessed(利用)</strong> but actually brought under consious control, to help us sleep and feel better.</p>
</blockquote>
<ul>
<li>harnessed 利用，这个单词很好用（在论文中）</li>
<li>to help do sth 固定搭配</li>
</ul>
<hr>
<p> Misfortune may be an actual（这里连读 &#x2F;bi na&#x2F;） blessing</p>
<hr>
<p>department stores 百货商店</p>
<hr>
<p><img src="/images/2022-08-26-13-12-23.png"></p>
<ul>
<li>be immune to 对…免疫</li>
<li>yet 并列连词，表示前后两句话的转折关系</li>
<li>assimilate 同化<br><img src="/images/2022-08-26-13-43-36.png"></li>
</ul>
<hr>
<p><img src="/images/2022-08-26-13-49-52.png"></p>
<ul>
<li>lean v 倾斜的，a 肉少的，贫乏的</li>
<li>hold v 保留…</li>
<li>all over 到处都是; 到处，遍及; 全部完结;</li>
<li>sleeper 露宿者<blockquote>
<p>thought they come from all over<br><img src="/images/2022-08-26-13-59-49.png"></p>
</blockquote>
</li>
</ul>
<hr>
<p><img src="/images/2022-08-26-17-35-00.png"></p>
<ul>
<li>a set of 一套，一组</li>
<li>sovereign n 君主，独立自主的</li>
<li>viable 可行的</li>
</ul>
<hr>
<p><img src="/images/2022-08-26-17-46-47.png"></p>
<hr>
<p><img src="/images/2022-09-04-09-29-56.png"></p>
<ul>
<li>eluded 难倒</li>
<li>suit sb to do sth 让某人去做某事</li>
</ul>
<hr>
<h2 id="Stocks"><a href="#Stocks" class="headerlink" title="Stocks"></a>Stocks</h2><p>Stocks rushed lower on a jarring(使某人不安) inflation report, dashing hopes(破碎美梦) of many investors that prices would cool to allow The Federal Reserve to pause their aggressive effort to slow the economy with interest rate increases sometime soon.</p>
<h2 id="On-the"><a href="#On-the" class="headerlink" title="On the"></a>On the</h2><p>On the other hand, he did not accept as（后面没有动词，因此这里是连词） well founded the charge made by some of his critics that, while he was（while） a good observe, he had(that) no power of reasoning.</p>
<ul>
<li>Well founded 有事实依据的</li>
<li>charge 指责</li>
<li>reasoning 推理</li>
<li>这里的made，只有done，没有be,并且后面是by， 同时semantic上也是passive</li>
</ul>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>限制性和非限制性</title>
    <url>/2022/09/24/%E9%99%90%E5%88%B6%E6%80%A7%E5%92%8C%E9%9D%9E%E9%99%90%E5%88%B6%E6%80%A7/</url>
    <content><![CDATA[<p>限制性定语从句限制所修饰名词或代词的意义，一般说来如把从句去掉句子意思就不清楚，甚至失去意义。而非限制性定语从句主句(句子的其他部分)关系不太紧密，对所修饰名词或代词的意思没有太大影响，把它们拿掉，句子依然很完整，它们可以说是附加上去的东西，而且通常都有逗号把它们和句子的其他部分分开。具体说来，限制性定语从句与非限制性定语从句有以下几个方面的区别： </p>
<ul>
<li><ol>
<li>形式不同限定性定语从句主句和从句之间不用逗号隔开，口语中使用时也不停顿；而非限定性定语从句与主句之间通常有逗号隔开，口语中使用时有停顿。</li>
</ol>
</li>
<li><ol start="2">
<li>作用不同限定性定语从句用于对先行词的意义进行修饰、限制和识别，如果去掉，就会造成句意不完整或概念不清；而非限定性定语从句用于对先行词起补充说明作用，如果省略，句意仍然清楚、完整： People who take physical exercise live longer.<br>进行体育锻炼的人活得长些。(若把从句去掉句子就失去意义)</li>
</ol>
</li>
</ul>
<blockquote>
<p>His daughter, who is in Boston now, is coming home next week. 他女儿现在波士顿，下星期回来。(若把从句去句子意义仍然完整)</p>
</blockquote>
<ul>
<li><ol start="3">
<li>翻译不同在翻译定语从句时，一般把限定性定语从句翻译在它所修饰的先行词之前，而把非限定性定语从句与主句分开：He is the man whose car was stolen. 他就是汽车被窃的那个人。</li>
</ol>
</li>
</ul>
<blockquote>
<p>I’ve invited Jim, who lives in the next flat. 我请了吉姆，他就住在隔壁。</p>
</blockquote>
<p>我请了吉姆，他就住在隔壁。</p>
<ul>
<li><ol start="4">
<li>含义不同比较：I have a sister who is a doctor. 我有一个当医生的姐姐。(姐姐不止一个)<blockquote>
<p>I have a sister ,who is a doctor. 我有一个姐姐，她是当医生的。(只有一个姐姐)</p>
</blockquote>
</li>
</ol>
</li>
<li><ol start="5">
<li>先行词不同限定性定语从句的先行词只能是名词或代词，而非限定性定语从句的先行词则可以是名词或代词，也可以是短语或句子；另外，当先行词为专有名词或其他具有独一无二性的:</li>
</ol>
</li>
</ul>
<blockquote>
<p>Peter drove too fast, which was dangerous. 彼得开车很快，这是很危险的。(which指drive too fast)He changed his mind, which made me very angry. 他改变了主意，这使我很生气。(which指整个主句)Mr. Smith, who is our boss, will leave for Japan 我们的老板史密斯先生下周要去日本。(先行词为专有名词，要用非限制性定语从句修饰)</p>
</blockquote>
<blockquote>
<p>Her father, who has a lot of money, wishes her to study abroad. 她父亲很有钱，希望她出国学习。(先行词为表独一无二意义的普通名词，要用非限制性定语从句修饰)</p>
</blockquote>
<ul>
<li><ol start="6">
<li>关系词不同关系词that和why可用于限制性定语从句中，通常不用于非限制性定语从句；另外，在限制性定语从句中，关系词有时可以省略，而在非限制性定语从句中关系词一律不省略。</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2022/09/22/docker/docker/</url>
    <content><![CDATA[<h4 id="1-Docker-一些基本操作"><a href="#1-Docker-一些基本操作" class="headerlink" title="1.Docker 一些基本操作"></a>1.Docker 一些基本操作</h4><ul>
<li><p><a href="../docker-compose">一次docker-compose配置多个镜像，如Wordpress+mysql</a></p>
</li>
<li><p><a href="../dockerfile">DockerFile</a></p>
</li>
<li><p><a href="../network">Communicate containers</a></p>
</li>
<li><p><a href="../image">upload your images</a></p>
</li>
<li><p><a href="../backup">容器数据的备份与恢复</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
